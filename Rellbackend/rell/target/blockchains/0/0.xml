<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="moduleArgs">
                        <dict>
                            <entry key="game">
                                <dict>
                                    <entry key="admin_pubkey">
                                        <bytea>03B519082C905096E4B658E7ACA7B971DF3A9D3A1D04BBEBE342B59CCCDC6DC3BA</bytea>
                                    </entry>
                                    <entry key="token_name">
                                        <string>WONDER TOKEN</string>
                                    </entry>
                                </dict>
                            </entry>
                            <entry key="rell_modules.ft3.core">
                                <dict>
                                    <entry key="my_blockchain_description">
                                        <string>test_description</string>
                                    </entry>
                                    <entry key="my_blockchain_name">
                                        <string>test</string>
                                    </entry>
                                    <entry key="my_blockchain_website">
                                        <string>test_website</string>
                                    </entry>
                                    <entry key="rate_limit_active">
                                        <int>0</int>
                                    </entry>
                                    <entry key="rate_limit_max_points">
                                        <int>10</int>
                                    </entry>
                                    <entry key="rate_limit_points_at_account_creation">
                                        <int>1</int>
                                    </entry>
                                    <entry key="rate_limit_recovery_time">
                                        <int>5000</int>
                                    </entry>
                                </dict>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="modules">
                        <array>
                            <string>main</string>
                        </array>
                    </entry>
                    <entry key="sources_v0.10">
                        <dict>
                            <entry key="game/initialize_chain.rell">
                                <string>&#13;
// This operation is called once on a fresh chain to initialize stuffs&#13;
operation initialize_chain(){&#13;
  require(is_signer(chain_context.args.admin_pubkey));&#13;
  create_admin_account_if_needed();&#13;
  register_token_asset_if_needed();&#13;
&#13;
  // Originals&#13;
  initialize_originals();&#13;
  init_structures();&#13;
}&#13;
&#13;
/*&#13;
 * ADMIN ACCOUNT&#13;
 * The admin account would be the one to have all plots initially, and people would buy plots from the admin account by paying WONDER_TOKEN (below)&#13;
 */&#13;
&#13;
function admin_auth_descriptor(): ft3.acc.auth_descriptor {&#13;
  return ft3.acc.auth_descriptor(&#13;
    "S",&#13;
    [chain_context.args.admin_pubkey],&#13;
    [["A", "T"].to_gtv(), chain_context.args.admin_pubkey.to_hex().to_gtv()], // chain_context arguments is defined in config/run.xml&#13;
    gtv.from_bytes(x'a0020500')&#13;
  );&#13;
}&#13;
&#13;
function create_admin_account_if_needed() {&#13;
  val auth_descriptor = admin_auth_descriptor();&#13;
  val account = ft3.acc.account @? { .id == auth_descriptor.hash() };&#13;
&#13;
  if (account == null) {&#13;
    ft3.acc.create_account_with_auth(auth_descriptor);&#13;
  }&#13;
}&#13;
&#13;
&#13;
/*&#13;
 * FT3 ASSETS&#13;
 */&#13;
&#13;
// This would be the "money" token to buy stuffs&#13;
function register_token_asset_if_needed() {&#13;
  val token = ft3.core.asset @? { .id == (chain_context.args.token_name, chain_context.blockchain_rid).hash() };&#13;
&#13;
  if (token == null) {&#13;
    ft3.core.register_asset(chain_context.args.token_name, chain_context.blockchain_rid);&#13;
  }&#13;
}&#13;
</string>
                            </entry>
                            <entry key="game/module.rell">
                                <string>import ^.lib.interface.*;&#13;
import ^.lib.structure;&#13;
import ^.lib.instance;&#13;
import ^.lib.original.*;&#13;
import ^.lib.marketplace.*;&#13;
import ^.lib.marketplace.queries;&#13;
import ^.lib.marketplace.operations;&#13;
import ^.lib.structure.operations.dev;&#13;
&#13;
// this is just so that other files in this module (this folder) can use .ft3.acc directly instead of writting the whole import&#13;
namespace ft3 {&#13;
  import acc: rell_modules.ft3.account;&#13;
  import core: rell_modules.ft3.core;&#13;
}&#13;
&#13;
namespace original {&#13;
	import ^.lib.original.operations;&#13;
	import ^.lib.original.operations.dev;&#13;
}&#13;
&#13;
struct module_args {&#13;
  admin_pubkey: pubkey;&#13;
  token_name: text;&#13;
}</string>
                            </entry>
                            <entry key="game/originals.rell">
                                <string>import ^.lib.interface.*;&#13;
import ^.lib.structure.*;&#13;
import ^.lib.instance.*;&#13;
&#13;
function init_structures() {&#13;
	val ITradeable = defI(interface_("ITradeable", [&#13;
		"price": prop(propI(int())),&#13;
		"asset_id": prop(propI(int())),&#13;
		"image": prop(&#13;
			static(),&#13;
			propI(int())&#13;
		),&#13;
		"is_listed": prop(propBool(bool()))&#13;
	]));&#13;
	&#13;
	val IOriginal = defI(interface_("IOriginal",&#13;
		[&#13;
			"id": prop(propI(int())),&#13;
			"index": prop(propIndx(indx())),&#13;
			"owner": prop(propI(int())),&#13;
			"designer_id": prop(propI(int())),&#13;
			"designer_name": prop(propT(txt())),&#13;
			"description": prop(&#13;
				static(),&#13;
				propT(txt())&#13;
			)&#13;
		]&#13;
	));&#13;
	&#13;
	val ISword = defI(interface_("ISword", extends([IOriginal, ITradeable]), &#13;
		[&#13;
			"length": prop(&#13;
				static(),&#13;
				propI(int())&#13;
			),&#13;
			"material": prop(&#13;
				static(),&#13;
				propT(txt())&#13;
			)&#13;
		]&#13;
	));&#13;
	&#13;
	val SilverSword = def_(structure_("SilverSword", implements([ISword]),&#13;
		init([&#13;
			"image": x"abcdef123456".to_gtv(),&#13;
			"length": (100).to_gtv(),&#13;
			"material": "silver".to_gtv(),&#13;
			"designer_name": "Armani".to_gtv()&#13;
		])&#13;
	));&#13;
	&#13;
	val IronSword = def_(structure_("IronSword", implements([ISword]),&#13;
		init([&#13;
			"image": x"abcdef123456".to_gtv(),			&#13;
			"length": (120).to_gtv(),&#13;
			"material": "iron".to_gtv()&#13;
		])&#13;
	));&#13;
	&#13;
	val silverSword1 = new_(instance_(SilverSword));&#13;
	val silverSword2 = new_(instance_(SilverSword));&#13;
	&#13;
	val ironSword1 = new_(instance_(IronSword));&#13;
	val ironSword2 = new_(instance_(IronSword));&#13;
}</string>
                            </entry>
                            <entry key="game/player.rell">
                                <string>// You can't put all these 3 attributes on the same line, because the "key" keyword mean that the combination of all attributes on that line must be unique.&#13;
// So if you write `key username : text, pubkey : byte_array, avatar : integer;`&#13;
// it will mean that: &#13;
//  1. You can't have user with the same exact combination of pubkey, username, avatar&#13;
//  2. But you CAN have 2 users with the same username but different avatar, or 2 users with the same pubkey but different username)&#13;
&#13;
entity player {&#13;
  key username: text; // So putting only username on a "key" line will ensure that each user must use a different username&#13;
  key account: ft3.acc.account; // since Original depends on ft3 we will use ft3 account system here&#13;
  avatar: integer;&#13;
}&#13;
&#13;
// Return data of queries for player&#13;
struct player_info {&#13;
  id: byte_array;&#13;
  username: text;&#13;
  avatar: integer;&#13;
  tokens: integer;&#13;
}&#13;
&#13;
/*&#13;
 *  OPERATIONS&#13;
 */&#13;
&#13;
operation create_player(&#13;
  username: text,&#13;
  avatar: integer,&#13;
  account_id: byte_array,&#13;
  auth_descriptor_id: byte_array&#13;
){&#13;
  val account = ft3.acc.auth_and_log(account_id, auth_descriptor_id, ["A"]);&#13;
&#13;
  // create the token wallet for player, see init.rell&#13;
  ft3.core.ensure_balance( account,  ft3.core.asset @ { .name == chain_context.args.token_name } );&#13;
&#13;
  // add player to table&#13;
  create player( username, avatar, account );	&#13;
}&#13;
&#13;
/*&#13;
 *  QUERIES&#13;
 */&#13;
&#13;
query find_by_account_id(account_id: byte_array) {&#13;
  val player = player @? { .account.id == account_id };&#13;
&#13;
  if(player == null){&#13;
    return null;&#13;
  }&#13;
&#13;
  return get_player_info(player);&#13;
}&#13;
&#13;
query find_by_username(username: text){&#13;
  val player = player @? { .username == username };&#13;
&#13;
  if(player == null){&#13;
    return null;&#13;
  }&#13;
&#13;
  return get_player_info(player);&#13;
}&#13;
&#13;
query lookup_tokens(account_id: byte_array){&#13;
  val player = player @? { .account.id == account_id };&#13;
&#13;
  if(player == null){&#13;
    return null;&#13;
  }&#13;
&#13;
  return calculate_tokens( player.account );&#13;
}&#13;
&#13;
/*&#13;
 *  FUNCTIONS&#13;
 */&#13;
&#13;
function calculate_tokens(account : ft3.acc.account) : integer{&#13;
  val token = ft3.core.asset @ { .id == (chain_context.args.token_name, chain_context.blockchain_rid).hash() };&#13;
  var token_balance = (ft3.core.ensure_balance(account, token)).amount;&#13;
&#13;
  return token_balance;&#13;
}&#13;
&#13;
function get_player_info(player) : player_info {&#13;
  val tokens = calculate_tokens( player.account );&#13;
&#13;
  return player_info(&#13;
    id = player.account.id,&#13;
    username = player.username,&#13;
    avatar = player.avatar,&#13;
    tokens = tokens&#13;
  );&#13;
}</string>
                            </entry>
                            <entry key="lib/component_definition/main.rell">
                                <string>import ^.interface.*;&#13;
import ^.structure;&#13;
import ^.e.*;&#13;
&#13;
struct description {&#13;
	value: text;&#13;
}&#13;
&#13;
enum property_type {&#13;
	integer,&#13;
	text,&#13;
	indx,&#13;
	byte_array,&#13;
	interface,&#13;
	structure,&#13;
	account,&#13;
	boolean,&#13;
	id,&#13;
	_enum&#13;
}&#13;
&#13;
struct implements {&#13;
	interfaces: list&lt;interface&gt;;&#13;
}&#13;
&#13;
struct static {&#13;
	value: boolean = true;&#13;
}&#13;
&#13;
struct readonly {&#13;
	value: boolean = true;&#13;
}&#13;
&#13;
struct optional {&#13;
	value: boolean = true;&#13;
}&#13;
&#13;
struct prop_type_struct {&#13;
	type: property_type;&#13;
	type_gtv: gtv;&#13;
}&#13;
&#13;
struct max_count {&#13;
	value: integer;&#13;
}&#13;
&#13;
struct tag {&#13;
	name;&#13;
	value = value("");&#13;
}&#13;
&#13;
struct value {&#13;
	value: text;&#13;
}&#13;
&#13;
struct meta {&#13;
	tags: list&lt;tag&gt;;&#13;
}&#13;
&#13;
struct prop {&#13;
	readonly = readonly(false);&#13;
	optional = optional(false);&#13;
	static = static(false);&#13;
	meta = meta(list&lt;tag&gt;());&#13;
	prop_type_struct;&#13;
}&#13;
&#13;
function propI(int): prop_type_struct {&#13;
	return prop_type_struct(property_type.integer, int.to_gtv());&#13;
}&#13;
&#13;
struct chain {&#13;
	id: byte_array;&#13;
}&#13;
&#13;
struct int {&#13;
	min: integer = integer.MIN_VALUE;&#13;
	max: integer = integer.MAX_VALUE;&#13;
	value: integer? = null;&#13;
}&#13;
&#13;
function propT(txt): prop_type_struct {&#13;
	return prop_type_struct(property_type.text, txt.to_gtv());&#13;
}&#13;
&#13;
struct txt {&#13;
	max_length: integer = 256;&#13;
	value: text? = null;&#13;
}&#13;
&#13;
function propIndx(indx): prop_type_struct {&#13;
	return prop_type_struct(property_type.indx, indx.to_gtv());&#13;
}&#13;
&#13;
struct indx {&#13;
	max_count: integer? = null;&#13;
}&#13;
&#13;
struct configure {&#13;
	props: map&lt;text, gtv&gt; = map&lt;text, gtv&gt;();&#13;
}&#13;
&#13;
struct bytes {&#13;
	max_length: integer = 256;&#13;
	value: byte_array? = null;&#13;
}&#13;
&#13;
function propB(bytes): prop_type_struct {&#13;
	return prop_type_struct(property_type.byte_array, bytes.to_gtv());&#13;
}&#13;
&#13;
struct account {&#13;
}&#13;
&#13;
function propA(account): prop_type_struct {&#13;
	return prop_type_struct(property_type.account, account.to_gtv());&#13;
}&#13;
&#13;
struct inf {&#13;
	interface;&#13;
}&#13;
&#13;
function propInf(inf): prop_type_struct {&#13;
	return prop_type_struct(property_type.interface, inf.to_gtv());&#13;
}&#13;
&#13;
struct strct {&#13;
	structure.structure;&#13;
}&#13;
&#13;
function propS(strct): prop_type_struct {&#13;
	return prop_type_struct(property_type.structure, strct.to_gtv());&#13;
}&#13;
&#13;
struct bool {&#13;
	value: boolean? = null;&#13;
}&#13;
&#13;
function propBool(bool): prop_type_struct {&#13;
	return prop_type_struct(property_type.boolean, bool.to_gtv());&#13;
}&#13;
&#13;
struct id {&#13;
}&#13;
&#13;
function propID(id): prop_type_struct {&#13;
	return prop_type_struct(property_type.id, id.to_gtv());&#13;
}&#13;
&#13;
struct enm {&#13;
	_enum;&#13;
}&#13;
&#13;
function propE(enm): prop_type_struct {&#13;
	return prop_type_struct(property_type._enum, enm.to_gtv());&#13;
}&#13;
&#13;
struct where {&#13;
	name;&#13;
	value: gtv;&#13;
}</string>
                            </entry>
                            <entry key="lib/e/main.rell">
                                <string>&#13;
entity _enum {&#13;
	key name;&#13;
}&#13;
&#13;
entity enum_value {&#13;
	key _enum, value: text;&#13;
}&#13;
&#13;
function Enum(name): _enum {&#13;
	return _enum @ { name };&#13;
}&#13;
&#13;
function enum_(name, values: list&lt;text&gt;): _enum {&#13;
	val e = create _enum(name);&#13;
	&#13;
	for (value in values) {&#13;
		create enum_value(e, value);&#13;
	}&#13;
	&#13;
	return e;&#13;
}&#13;
&#13;
function e_value(e: name, value: name): enum_value {&#13;
	return enum_value @ { ._enum.name == e, .value == value };&#13;
}&#13;
&#13;
function en_value(e: _enum, value: name): enum_value {&#13;
	return enum_value @ { e, value };&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/boolean.rell">
                                <string>entity instance_property_value_boolean {&#13;
	key instance_property;&#13;
	mutable value: boolean;&#13;
}&#13;
&#13;
/*&#13;
 * Get &amp; Set functions&#13;
 */&#13;
 &#13;
function set_property_boolean(instance, path: text, value: boolean) {&#13;
	_set_property_boolean(_instance_property_of_path(instance, path), value);&#13;
}&#13;
&#13;
function _set_property_boolean(instance_property, value: boolean) {	&#13;
	require_instance_property_not_readonly(instance_property);&#13;
	&#13;
	val property_value = instance_property_value_boolean @? { instance_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create instance_property_value_boolean(&#13;
			instance_property,&#13;
			value = value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_property_boolean(instance, path: text): boolean? {&#13;
	return _get_property_boolean(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_boolean(instance_property): boolean? {&#13;
	require(&#13;
		instance_property_type(instance_property) == property_type.boolean&#13;
	);&#13;
	&#13;
	return instance_property_value_boolean @? { &#13;
		instance_property	&#13;
	}.value;&#13;
}&#13;
&#13;
function _unset_instance_property_boolean(instance_property) {&#13;
	delete instance_property_value_boolean @? {&#13;
		instance_property&#13;
	};&#13;
}&#13;
&#13;
/*&#13;
 * Query functions&#13;
 */&#13;
&#13;
function find_one_boolean(structure, property_name: text, value: boolean): instance? {&#13;
	val instances = instance_property_value_boolean @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_boolean(structure, property_name: text, value: boolean): list&lt;instance&gt; {&#13;
	return instance_property_value_boolean @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance );&#13;
}&#13;
&#13;
/*&#13;
 * Initialization&#13;
 */&#13;
&#13;
function _initialize_boolean_property(instance_property, init_value: gtv?) {&#13;
	val prop = instance_property.structure_property;&#13;
	val init_value_boolean = if (init_value??) boolean.from_gtv(init_value) else null;&#13;
	&#13;
	val default_value = &#13;
		if (instance_property.structure_property.value.size() != 0) &#13;
			boolean.from_gtv(gtv.from_bytes(instance_property.structure_property.value)) &#13;
		else &#13;
			null;&#13;
&#13;
	require(&#13;
		default_value != null &#13;
			or &#13;
		init_value_boolean != null &#13;
			or &#13;
		prop.optional == true,&#13;
		"Non-optional property '" + prop.name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly == false&#13;
			or&#13;
		(&#13;
			(default_value == null or init_value_boolean == null) &#13;
				and &#13;
			prop.readonly == true&#13;
		),&#13;
		"Readonly property '" + prop.name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_boolean ?: default_value;&#13;
	&#13;
	if (v??) {&#13;
		create instance_property_value_boolean(&#13;
			instance_property,&#13;
			v&#13;
		);&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/byte_array.rell">
                                <string>entity instance_property_value_byte_array {&#13;
	instance_property;&#13;
	mutable value: byte_array;&#13;
}&#13;
&#13;
function set_property_byte_array(instance, path: text, value: byte_array) {&#13;
	_set_property_byte_array(_instance_property_of_path(instance, path), value);&#13;
}&#13;
&#13;
function _set_property_byte_array(instance_property, value: byte_array) {&#13;
	require_instance_property_not_readonly(instance_property);&#13;
	&#13;
	val property_value = instance_property_value_byte_array @? { instance_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create instance_property_value_byte_array(&#13;
			instance_property,&#13;
			value = value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_property_byte_array(instance, path: text): byte_array? {&#13;
	return _get_property_byte_array(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_byte_array(instance_property): byte_array? {&#13;
	require(&#13;
		instance_property_type(instance_property) == property_type.byte_array&#13;
	);&#13;
	&#13;
	return instance_property_value_byte_array @? {&#13;
		instance_property&#13;
	}.value;&#13;
}&#13;
&#13;
function _unset_instance_property_byte_array(instance_property) {&#13;
	delete instance_property_value_byte_array @? {&#13;
		instance_property&#13;
	};&#13;
}&#13;
&#13;
function find_one_byte_array(structure, property_name: text, value: byte_array): instance? {&#13;
	val instances = instance_property_value_byte_array @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_byte_array(structure, property_name: text, value: byte_array): list&lt;instance&gt; {&#13;
	return instance_property_value_byte_array @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance );&#13;
}&#13;
&#13;
function _initialize_byte_array_property(instance_property, init_value: gtv?) {&#13;
	val prop = instance_property.structure_property;&#13;
	val init_value_byte_array = if (init_value??) byte_array.from_gtv(init_value) else null;&#13;
	&#13;
	val default_value = &#13;
		if (instance_property.structure_property.value.size() != 0) &#13;
			byte_array.from_gtv(gtv.from_bytes(instance_property.structure_property.value)) &#13;
		else &#13;
			null;&#13;
&#13;
	require(&#13;
		default_value != null or init_value_byte_array != null or prop.optional == true,&#13;
		"Non-optional property '" + prop.name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly == false&#13;
			or&#13;
		((default_value == null or init_value_byte_array == null) and prop.readonly == true),&#13;
		"Readonly property '" + prop.name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_byte_array ?: default_value;&#13;
	&#13;
	if (v??) {&#13;
		create instance_property_value_byte_array(&#13;
			instance_property,&#13;
			v&#13;
		);&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/enum.rell">
                                <string>&#13;
entity instance_property_value_enum {&#13;
	key instance_property;&#13;
	mutable value: enum_value;&#13;
}&#13;
&#13;
function set_property_enum(instance, path: text, enum_value) {&#13;
	_set_property_enum(_instance_property_of_path(instance, path), enum_value);&#13;
}&#13;
&#13;
function _set_property_enum(instance_property, value: enum_value) {&#13;
	require_instance_property_not_readonly(instance_property);&#13;
	&#13;
	val property_value = instance_property_value_enum @? { instance_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create instance_property_value_enum(&#13;
			instance_property,&#13;
			value = value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_property_enum(instance, path: text): enum_value? {&#13;
	return _get_property_enum(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_enum(instance_property): enum_value? {&#13;
	require(&#13;
		instance_property_type(instance_property) == property_type._enum&#13;
	);&#13;
	&#13;
	return instance_property_value_enum @? {&#13;
		instance_property&#13;
	}.value;&#13;
}&#13;
&#13;
function _get_property_enum_serialized(instance_property): gtv? {&#13;
	return _get_property_enum(instance_property)?.value?.to_gtv();&#13;
}&#13;
&#13;
function find_one_enum(structure, property_name: name, value: enum_value): instance? {&#13;
	val instances = instance_property_value_enum @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_enum(structure, property_name: name, value: enum_value): list&lt;instance&gt; {&#13;
	return instance_property_value_enum @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance );&#13;
} &#13;
&#13;
function _initialize_enum_property(instance_property, init_value: gtv?) {&#13;
	val prop = instance_property.structure_property;&#13;
	val init_value_enum = if (init_value??) enum_value.from_gtv(init_value) else null;&#13;
&#13;
	require(&#13;
		init_value_enum != null or prop.optional == true,&#13;
		"Non-optional property '" + prop.name + "' is not initialized"&#13;
	); &#13;
	&#13;
	if (init_value_enum??) {&#13;
		create instance_property_value_enum(&#13;
			instance_property,&#13;
			init_value_enum&#13;
		);&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/ft3_account.rell">
                                <string>import ft3: rell_modules.ft3.account;&#13;
&#13;
entity instance_property_value_account {&#13;
	key instance_property;&#13;
	mutable value: ft3.account;&#13;
}&#13;
&#13;
function Account(id: byte_array): ft3.account {&#13;
	return ft3.account @ { id };&#13;
}&#13;
&#13;
function set_property_account(instance, path: text, value: ft3.account) {&#13;
	_set_property_account(_instance_property_of_path(instance, path), value);&#13;
}&#13;
&#13;
function _set_property_account(instance_property, value: ft3.account) {&#13;
	require_instance_property_not_readonly(instance_property);&#13;
	&#13;
	val property_value = instance_property_value_account @? { instance_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create instance_property_value_account(&#13;
			instance_property,&#13;
			value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_property_account(instance, path: text): ft3.account? {&#13;
	return _get_property_account(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_account(instance_property): ft3.account? {&#13;
	require(&#13;
		instance_property_type(instance_property) == property_type.account&#13;
	);&#13;
	&#13;
	return instance_property_value_account @? { &#13;
		instance_property&#13;
	}?.value;&#13;
}&#13;
&#13;
function _get_property_account_serialized(instance_property): gtv? {&#13;
	return _get_property_account(instance_property)?.id?.to_gtv();&#13;
}&#13;
&#13;
function find_one_account(structure, property_name: name, value: ft3.account): instance? {&#13;
	val instances = instance_property_value_account @* {&#13;
		.instance_property.instance.structure == structure,		&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_account(structure, property_name: name, value: ft3.account): list&lt;instance&gt; {&#13;
	return instance_property_value_account @* {&#13;
		.instance_property.instance.structure == structure,		&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance );&#13;
}&#13;
&#13;
/*&#13;
 * Initialization&#13;
 */&#13;
&#13;
function _initialize_ft3_account_property(instance_property, init_value: gtv?)  {&#13;
	val prop = instance_property.structure_property;&#13;
	&#13;
	var account: ft3.account? = null;&#13;
	&#13;
	if (init_value??) {&#13;
		if (is_integer(init_value)) {&#13;
			val rowid = rowid.from_gtv(init_value);&#13;
			account = ft3.account @ { rowid };&#13;
		} else if (is_text_or_byte_array(init_value)) {&#13;
			val account_id = byte_array.from_gtv(init_value);&#13;
			account = Account(account_id);&#13;
		} else {&#13;
			throw("Don't know how to initialize a property of ft3 account type with value: " + init_value);&#13;
		}&#13;
	}&#13;
	&#13;
&#13;
	require(&#13;
		account != null &#13;
			or &#13;
		prop.optional == true,&#13;
		"Non-optional property '" + prop.name + "' is not initialized"&#13;
	); &#13;
	&#13;
	&#13;
	&#13;
	if (account??) {&#13;
		create instance_property_value_account(&#13;
			instance_property,&#13;
			account&#13;
		);&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/functions.rell">
                                <string>&#13;
function _instance_property(instance, name): instance_property {&#13;
	return instance_property @ { .structure_property.name == name, instance };&#13;
}&#13;
&#13;
function _instance_property_of_path(instance, path: text): instance_property {&#13;
	val (nested_instance, name) &#13;
		= _get_instance_and_property_name_of_path(instance, path);&#13;
		&#13;
	return _instance_property(nested_instance, name);&#13;
}&#13;
&#13;
function _get_instance_properties_of_interface(&#13;
	instance, &#13;
	interface&#13;
): set&lt;instance_property&gt; {&#13;
	val instance_properties = (&#13;
		si: structure_interface,&#13;
		ei: extended_interface,&#13;
		ip: instance_property, &#13;
		infp: interface_property&#13;
	) @* {&#13;
		si.structure == instance.structure,&#13;
		si.interface == interface &#13;
			or &#13;
		(ei.extended == interface and si.interface == ei.base), &#13;
		infp.interface == si.interface,&#13;
		ip.instance == instance,&#13;
		ip.structure_property.name == infp.name&#13;
	} ( ip );&#13;
	&#13;
	return set&lt;instance_property&gt;(instance_properties);&#13;
}&#13;
&#13;
function _get_instance_properties_of_interfaces(&#13;
	instance, &#13;
	interfaces: list&lt;interface&gt;&#13;
): set&lt;instance_property&gt; {&#13;
	val instance_properties = set&lt;instance_property&gt;();&#13;
	&#13;
	for (interface in interfaces) {&#13;
		instance_properties.add_all(&#13;
			_get_instance_properties_of_interface(instance, interface)&#13;
		);	&#13;
	}&#13;
	&#13;
	return instance_properties;&#13;
}&#13;
&#13;
function _get_instance_property_names_from(&#13;
	instance, &#13;
	interfaces: list&lt;interface&gt;&#13;
): set&lt;name&gt; {&#13;
	val property_names = set&lt;name&gt;();&#13;
	val instance_properties = _get_instance_properties_of_interfaces(instance, interfaces);&#13;
	for (instance_property in instance_properties) {&#13;
		property_names.add(instance_property_name(instance_property));&#13;
	}&#13;
	return property_names;&#13;
}&#13;
&#13;
function _get_instance_properties_of_interface_type(instance, interface): list&lt;instance_property&gt; {&#13;
	return ( &#13;
		ip: instance_property,&#13;
		ei: extended_interface,&#13;
		spi: structure_property_interface,&#13;
		ipvi: instance_property_value_instance&#13;
	) @* { &#13;
		ip.instance == instance,&#13;
		ip.structure_property.type == property_type.interface,&#13;
		spi.structure_property == ip.structure_property,&#13;
		spi.interface == interface&#13;
			or &#13;
		(spi.interface == ei.extended and ei.base == interface)&#13;
	} ( ip );&#13;
}&#13;
&#13;
function _get_instance_properties_of_interface_types(instance, interfaces: list&lt;interface&gt;): list&lt;instance_property&gt; {&#13;
	val instance_properties = set&lt;instance_property&gt;();&#13;
	for (interface in interfaces) {&#13;
		instance_properties.add_all(_get_instance_properties_of_interface_type(instance, interface));&#13;
	}&#13;
	return instance_properties.sorted();&#13;
}&#13;
&#13;
function _get_instance_and_property_name_of_path(instance, path: text): (instance, name) {&#13;
	//TODO: validate path&#13;
	val path_components = path.split(".");&#13;
	&#13;
	if (path_components.size() == 1) {&#13;
		return (instance, path_components[0]);&#13;
	}&#13;
	&#13;
	var child_instance = instance;&#13;
	&#13;
	for (i in range(0, path_components.size()-1)) {&#13;
		child_instance = get_property_instance(child_instance, path_components[i])!!;&#13;
	}&#13;
	&#13;
	return (child_instance, path_components[path_components.size()-1]);&#13;
}&#13;
&#13;
function deep_copy(original_instance: instance): instance {&#13;
	require(&#13;
		not original_instance.structure.is_entity,&#13;
		"Cannot deep copy entity instances"&#13;
	);&#13;
	&#13;
	val instance = create instance(original_instance.structure);&#13;
	&#13;
	_copy_integer_properties(original_instance, instance);&#13;
	_copy_text_properties(original_instance, instance);&#13;
	_copy_byte_array_properties(original_instance, instance);&#13;
	_copy_boolean_properties(original_instance, instance);&#13;
	_copy_account_properties(original_instance, instance);&#13;
	_copy_instance_properties(original_instance, instance);&#13;
	//TODO: analyze how to handle index properties&#13;
&#13;
	return instance;&#13;
}&#13;
&#13;
function _copy_integer_properties(source: instance, destination: instance) {&#13;
	val instance_properties &#13;
		= instance_properties_of_type(source, property_type.integer);&#13;
	&#13;
	for (property in instance_properties) {&#13;
		val instance_property = create instance_property(&#13;
			destination,&#13;
			property.structure_property&#13;
		);&#13;
		&#13;
		val value = _get_property_integer(property);&#13;
		if (value??) {&#13;
			create instance_property_value_integer(&#13;
				instance_property,&#13;
				.value = value				&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function _copy_text_properties(source: instance, destination: instance) {&#13;
	val instance_properties &#13;
		= instance_properties_of_type(source, property_type.text);&#13;
	&#13;
	for (property in instance_properties) {&#13;
		val instance_property = create instance_property(&#13;
			destination,&#13;
			property.structure_property&#13;
		);&#13;
		&#13;
		val value = _get_property_text(property);&#13;
		if (value??) {&#13;
			create instance_property_value_text(&#13;
				instance_property,&#13;
				.value = value				&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function _copy_byte_array_properties(source: instance, destination: instance) {&#13;
	val instance_properties &#13;
		= instance_properties_of_type(source, property_type.byte_array);&#13;
	&#13;
	for (property in instance_properties) {&#13;
		val instance_property = create instance_property(&#13;
			destination,&#13;
			property.structure_property&#13;
		);&#13;
		&#13;
		val value = _get_property_byte_array(property);&#13;
		if (value??) {&#13;
			create instance_property_value_byte_array(&#13;
				instance_property,&#13;
				.value = value				&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function _copy_boolean_properties(source: instance, destination: instance) {&#13;
	val instance_properties = instance_properties_of_type(source, property_type.boolean);&#13;
	&#13;
	for (property in instance_properties) {&#13;
		val instance_property = create instance_property(&#13;
			destination,&#13;
			property.structure_property&#13;
		);&#13;
		&#13;
		val value = _get_property_boolean(property);&#13;
		if (value??) {&#13;
			create instance_property_value_boolean(&#13;
				instance_property,&#13;
				.value = value				&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function _copy_account_properties(source: instance, destination: instance) {&#13;
	val instance_properties &#13;
		= instance_properties_of_type(source, property_type.account);&#13;
	&#13;
	for (property in instance_properties) {&#13;
		val instance_property = create instance_property(&#13;
			destination,&#13;
			property.structure_property&#13;
		);&#13;
		&#13;
		val value = _get_property_account(property);&#13;
		if (value??) {&#13;
			create instance_property_value_account(&#13;
				instance_property,&#13;
				.value = value				&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function _copy_instance_properties(source: instance, destination: instance) {&#13;
	val instance_properties = instance_property @* {&#13;
		source, &#13;
		.structure_property.type == property_type.interface&#13;
			or &#13;
		.structure_property.type == property_type.structure&#13;
	};&#13;
	&#13;
	for (property in instance_properties) {&#13;
		val instance_property = create instance_property(&#13;
			destination,&#13;
			property.structure_property			&#13;
		);&#13;
		&#13;
		val value = _get_property_instance(property);&#13;
		if (value??) {&#13;
			val instance_value =&#13;
				if (value.structure.is_entity) &#13;
					value&#13;
				else&#13;
					deep_copy(value);&#13;
			&#13;
			create instance_property_value_instance(&#13;
				instance_property,&#13;
				value = instance_value&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function _delete_instance(instance) {&#13;
	require(&#13;
		not instance.structure.is_entity,&#13;
		"Cannot delete entity instance"&#13;
	);&#13;
	&#13;
	val is_assigned = (&#13;
		instance_property_value_instance @* { .value == instance }&#13;
	).size() &gt; 0;&#13;
	&#13;
	require(&#13;
		not is_assigned,&#13;
		"Cannot delete instance which is assigned"&#13;
	);&#13;
	&#13;
	delete instance_property_value_integer @* { &#13;
		.instance_property.instance == instance&#13;
	};&#13;
	&#13;
	delete instance_property_value_text @* {&#13;
		.instance_property.instance == instance		&#13;
	};&#13;
	&#13;
	delete instance_property_value_boolean @* {&#13;
		.instance_property.instance == instance&#13;
	};&#13;
	&#13;
	delete instance_property_value_byte_array @* {&#13;
		.instance_property.instance == instance		&#13;
	};&#13;
&#13;
	delete instance_property_value_index @* {&#13;
		.instance_property.instance == instance		&#13;
	};&#13;
	&#13;
	delete instance_property_value_account @* {&#13;
		.instance_property.instance == instance		&#13;
	};&#13;
	&#13;
	delete instance_property @* {&#13;
		instance&#13;
	};&#13;
	&#13;
	delete instance;&#13;
}&#13;
&#13;
function instance_properties_of_type(instance, property_type): list&lt;instance_property&gt; {&#13;
	return instance_property @* {&#13;
		instance, .structure_property.type == property_type &#13;
	};&#13;
}&#13;
&#13;
function get_instances_count(structure): integer {&#13;
	return instance @* { structure } ( .rowid ).size();&#13;
}&#13;
&#13;
function get_instances_max_count(structure): integer? {&#13;
	val property = structure_property @? { structure, .type == property_type.indx };&#13;
	&#13;
	if (not property??) return null;&#13;
	&#13;
	return structure_property_index_max_count @? {&#13;
		property&#13;
	}.value;&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/helper.rell">
                                <string>function is_map(gtv): boolean {&#13;
	return gtv.to_bytes()[0] == x"a4"[0];&#13;
}&#13;
&#13;
function is_list(gtv): boolean {&#13;
	return gtv.to_bytes()[0] == x"a5"[0];&#13;
}&#13;
&#13;
function is_text(gtv): boolean {&#13;
	return gtv.to_bytes()[0] == x"a2"[0];&#13;
}&#13;
&#13;
function is_text_or_byte_array(gtv): boolean {&#13;
	val first_byte = gtv.to_bytes()[0];&#13;
	return first_byte == x"a1"[0] or first_byte == x"a2"[0];&#13;
}&#13;
&#13;
function is_byte_array(gtv): boolean {&#13;
	return gtv.to_bytes()[0] == x"a2"[0];&#13;
}&#13;
&#13;
function is_integer(gtv): boolean {&#13;
	return gtv.to_bytes()[0] == x"a3"[0];&#13;
}&#13;
&#13;
function throw(message: text) {&#13;
	require(false, message);&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/id.rell">
                                <string>entity instance_property_value_id {&#13;
	key instance_property;&#13;
	key value: byte_array;&#13;
}&#13;
&#13;
function get_property_id(instance, path: text): byte_array {&#13;
	return _get_property_id(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_id(instance_property): byte_array {&#13;
	require(instance_property_type(instance_property) == property_type.id);&#13;
	return instance_property_value_id @ {&#13;
		instance_property&#13;
	}.value;&#13;
}&#13;
&#13;
function _initialize_id_property(instance_property, init_value: gtv?) {&#13;
	require(init_value??, "ID property cannot be null");&#13;
	&#13;
	create instance_property_value_id(&#13;
		instance_property,&#13;
		value = byte_array.from_gtv(init_value!!)&#13;
	);&#13;
}&#13;
&#13;
function find_id(structure, property_name: name, value: byte_array): instance? {&#13;
	return instance_property_value_id @? {&#13;
		.instance_property.instance.structure == structure,	&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value		&#13;
	} ( .instance_property.instance );	&#13;
}&#13;
&#13;
function find_one_id(structure, property_name: name, value: byte_array): instance? {&#13;
	return find_id(structure, property_name, value);&#13;
}&#13;
&#13;
function find_all_id(structure, property_name: name, value: byte_array): list&lt;instance&gt; {&#13;
	val instance = find_id(structure, property_name, value);&#13;
	&#13;
	if (instance == null) return list&lt;instance&gt;();&#13;
	&#13;
	return [instance];&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/index.rell">
                                <string>&#13;
entity instance_property_value_index {&#13;
	key instance_property, value: integer;&#13;
}&#13;
&#13;
function get_property_index(instance, path: text): integer {&#13;
	return _get_property_index(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_index(instance_property): integer {&#13;
	require(&#13;
		instance_property_type(instance_property) == property_type.indx&#13;
	);&#13;
	return instance_property_value_index @ {&#13;
		instance_property&#13;
	}.value;&#13;
}&#13;
&#13;
function _initialize_index_property(instance_property, init_value: gtv?) {&#13;
	val structure = instance_property.structure_property.structure;&#13;
	&#13;
	// TODO: convert to single function&#13;
	var count = get_instances_count(structure);&#13;
	val max_count = get_instances_max_count(structure);&#13;
	&#13;
	if (max_count??) {&#13;
		require(&#13;
			count &lt;= max_count, &#13;
			"Maximum instance count reached for structure '" + structure.name + "'"&#13;
		);&#13;
	}&#13;
	&#13;
	//TODO: analyze if two instances with same index could be concurrently created&#13;
	create instance_property_value_index(&#13;
		instance_property,&#13;
		value = count - 1&#13;
	);&#13;
}&#13;
&#13;
function find_one_index(structure, property_name: text, value: integer): instance? {&#13;
	val instances = instance_property_value_index @* {&#13;
		.instance_property.instance.structure == structure,	&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_index(structure, property_name: text, value: integer): list&lt;instance&gt; {&#13;
	return instance_property_value_index @* {&#13;
		.instance_property.instance.structure == structure,	&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance );&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/instance.rell">
                                <string>&#13;
entity instance_property_value_instance {&#13;
	instance_property;&#13;
	mutable value: instance;&#13;
}&#13;
&#13;
function set_property_instance(instance, path: text, value: instance) {&#13;
	_set_property_instance(_instance_property_of_path(instance, path), value);&#13;
}&#13;
&#13;
function _set_property_instance(instance_property, value: instance) {	&#13;
	require_instance_property_not_readonly(instance_property);&#13;
	require_instance_is_of_valid_type(instance_property, value);&#13;
	&#13;
	val instance_value = &#13;
		if (value.structure.is_entity)&#13;
			value&#13;
		else &#13;
			deep_copy(value);&#13;
	&#13;
	val property_value = instance_property_value_instance @? { instance_property };&#13;
	&#13;
	if (property_value??) {&#13;
		val old_value = property_value.value;&#13;
		&#13;
		property_value.value = instance_value;&#13;
		&#13;
		if (not old_value.structure.is_entity) {&#13;
			_delete_instance(old_value);&#13;
		}	&#13;
	} else {&#13;
		create instance_property_value_instance(&#13;
			instance_property,&#13;
			value = instance_value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function Instance(id: gtv): instance {&#13;
	if (not is_integer(id) and not is_text_or_byte_array(id)) {&#13;
		throw("Cannot load an instance by gtv: " + id);&#13;
	}&#13;
	&#13;
	return &#13;
		if (is_integer(id)) &#13;
			instance.from_gtv(id)&#13;
		else &#13;
			find_by_id(byte_array.from_gtv(id))!!;&#13;
}&#13;
&#13;
function get_property_instance(instance, path: text): instance? {&#13;
	return _get_property_instance(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_instance(instance_property): instance? {&#13;
	_require_property_structure_or_interface(instance_property);&#13;
	return instance_property_value_instance @? { instance_property }.value;&#13;
}&#13;
&#13;
function _get_property_instance_serialized(instance_property): gtv? {&#13;
	return _get_property_instance_serialized_with_rules(&#13;
		instance_property, all()&#13;
	);&#13;
}&#13;
&#13;
function find_one_instance(structure, property_name: name, value: instance): instance? {&#13;
	val instances = instance_property_value_instance @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_instance(structure, property_name: name, value: instance): list&lt;instance&gt; {&#13;
	//TODO: require property type is structure or interface&#13;
	&#13;
	return instance_property_value_instance @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) ;&#13;
}&#13;
&#13;
function _get_property_instance_serialized_with_rules(&#13;
	instance_property, &#13;
	property_rules: list&lt;instance_map_rule&gt;&#13;
): gtv? {&#13;
	val instance = _get_property_instance(instance_property);&#13;
	&#13;
	if (not instance??) return null;&#13;
	&#13;
	val instance_rules = _mapping_rules(instance, property_rules);&#13;
	&#13;
	return map_instance(instance, instance_rules, property_rules).to_gtv();&#13;
}&#13;
&#13;
/*&#13;
 * Initialization&#13;
 */&#13;
&#13;
function _initialize_instance_property(instance_property, init_value: gtv?) {&#13;
	val prop = instance_property.structure_property;&#13;
	&#13;
	if (init_value??) {&#13;
		if (is_integer(init_value)) {&#13;
			create instance_property_value_instance(&#13;
				instance_property,&#13;
				instance @ { rowid.from_gtv(init_value) }&#13;
			);&#13;
		} else if(is_map(init_value)) {&#13;
			val properties = map&lt;text, gtv&gt;.from_gtv(init_value);&#13;
			val structure = structure_property_structure @ { prop }.structure;&#13;
			val instance = new_(instance_(structure, init(properties)));&#13;
			create instance_property_value_instance(&#13;
				instance_property,&#13;
				instance&#13;
			);&#13;
		} else {&#13;
			throw("Unsupported argument type");&#13;
		}&#13;
	}&#13;
	&#13;
	//TODO: require non-optional property initialized&#13;
	//TODO: require read-only property initialized only once&#13;
	//TODO: handle default value&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/instance/integer.rell">
                                <string>entity instance_property_value_integer {&#13;
	key instance_property;&#13;
	mutable value: integer;&#13;
}&#13;
&#13;
/*&#13;
 * Get &amp; Set functions&#13;
 */&#13;
 &#13;
function set_property_integer(instance, path: text, value: integer) {&#13;
	_set_property_integer(_instance_property_of_path(instance, path), value);&#13;
}&#13;
&#13;
function _set_property_integer(instance_property, value: integer) {	&#13;
	require_instance_property_not_readonly(instance_property);&#13;
	&#13;
	val property_value = instance_property_value_integer @? { instance_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create instance_property_value_integer(&#13;
			instance_property,&#13;
			value = value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_property_integer(instance, path: text): integer? {&#13;
	return _get_property_integer(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_integer(instance_property): integer? {&#13;
	require(&#13;
		instance_property_type(instance_property) == property_type.integer&#13;
	);&#13;
	&#13;
	return instance_property_value_integer @? { instance_property }.value;&#13;
}&#13;
&#13;
function _unset_instance_property_integer(instance_property) {&#13;
	delete instance_property_value_integer @? {&#13;
		instance_property&#13;
	};&#13;
}&#13;
&#13;
/*&#13;
 * Query functions&#13;
 */&#13;
&#13;
function find_one_integer(structure, property_name: text, value: integer): instance? {&#13;
	val instances = instance_property_value_integer @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_integer(structure, property_name: text, value: integer): list&lt;instance&gt; {&#13;
	return instance_property_value_integer @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance );&#13;
}&#13;
&#13;
/*&#13;
 * Initialization&#13;
 */&#13;
&#13;
function _initialize_integer_property(instance_property, init_value: gtv?) {&#13;
	val prop = instance_property.structure_property;&#13;
	val init_value_integer = if (init_value??) integer.from_gtv(init_value) else null;&#13;
	&#13;
	val default_value = &#13;
		if (instance_property.structure_property.value.size() != 0) &#13;
			integer.from_gtv(gtv.from_bytes(instance_property.structure_property.value)) &#13;
		else &#13;
			null;&#13;
&#13;
	require(&#13;
		default_value != null &#13;
			or &#13;
		init_value_integer != null &#13;
			or &#13;
		prop.optional == true,&#13;
		"Non-optional property '" + prop.name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly == false&#13;
			or&#13;
		(&#13;
			(default_value == null or init_value_integer == null) &#13;
				and &#13;
			prop.readonly == true&#13;
		),&#13;
		"Read-only property '" + prop.name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_integer ?: default_value;&#13;
	&#13;
	if (v??) {&#13;
		create instance_property_value_integer(&#13;
			instance_property,&#13;
			v&#13;
		);&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/main.rell">
                                <string>&#13;
import ^.structure.*;&#13;
import ^.component_definition.{&#13;
	property_type&#13;
};&#13;
import ^.original;&#13;
&#13;
entity instance {&#13;
	index structure;&#13;
}&#13;
&#13;
entity instance_property {&#13;
	index instance;&#13;
	key instance, structure_property;&#13;
}&#13;
&#13;
/*&#13;
 * Instantiation&#13;
 */&#13;
&#13;
struct instance_ {&#13;
	structure;&#13;
	init = init(map&lt;text, gtv&gt;());&#13;
}&#13;
&#13;
function new_(instance_): instance {&#13;
	val instance = create instance(instance_.structure);	&#13;
	_create_properties(instance, instance_.init);&#13;
	return instance;&#13;
}&#13;
&#13;
/*&#13;
 * Get &amp; Set&#13;
 */&#13;
&#13;
function set_property(instance, path: text, value: gtv) {&#13;
	val property = _instance_property_of_path(instance, path);&#13;
	&#13;
	when(instance_property_type(property)) {&#13;
		property_type.integer -&gt; &#13;
			_set_property_integer(property, integer.from_gtv(value));	&#13;
		property_type.text -&gt; &#13;
			_set_property_text(property, text.from_gtv(value));	&#13;
		property_type.byte_array -&gt; &#13;
			_set_property_byte_array(property, byte_array.from_gtv(value));&#13;
		property_type.boolean -&gt;&#13;
			_set_property_boolean(property, boolean.from_gtv(value));&#13;
		property_type.interface,&#13;
		property_type.structure -&gt;&#13;
			_set_property_instance(property, Instance(value));&#13;
		property_type._enum -&gt;&#13;
			_set_property_enum(property, enum_value.from_gtv(value));&#13;
	}&#13;
}&#13;
&#13;
function get_property(instance, path: text): gtv? {&#13;
	val instance_property = _instance_property_of_path(instance, path);&#13;
	&#13;
	return _get_property(instance_property);&#13;
}&#13;
&#13;
function _get_property(instance_property): gtv? {&#13;
	when (instance_property_type(instance_property)) {&#13;
		property_type.integer -&gt; &#13;
			return _get_property_integer(instance_property)?.to_gtv();&#13;
		property_type.text -&gt;&#13;
			return _get_property_text(instance_property)?.to_gtv();&#13;
		property_type.byte_array -&gt; &#13;
			return _get_property_byte_array(instance_property)?.to_gtv();&#13;
		property_type.boolean -&gt;&#13;
			return _get_property_boolean(instance_property)?.to_gtv();&#13;
		property_type.id -&gt;&#13;
			return _get_property_id(instance_property).to_gtv();&#13;
		property_type.indx -&gt;&#13;
			return _get_property_index(instance_property).to_gtv();&#13;
		property_type.account -&gt; &#13;
			return _get_property_account(instance_property)?.to_gtv();&#13;
		property_type._enum -&gt;&#13;
			return _get_property_enum(instance_property)?.to_gtv();&#13;
		property_type.interface,&#13;
		property_type.structure -&gt;&#13;
			return _get_property_instance(instance_property)?.to_gtv();&#13;
	}&#13;
}&#13;
&#13;
function get_property_serialized(instance, path: text): gtv? {&#13;
	val instance_property = _instance_property_of_path(instance, path);&#13;
	&#13;
	return _get_property_serialized(instance_property);&#13;
}&#13;
&#13;
function _get_property_serialized(instance_property): gtv? {&#13;
	return _get_property_serialized_with_rules(&#13;
		instance_property,&#13;
		all()&#13;
	);&#13;
}&#13;
&#13;
function _get_property_serialized_with_rules(&#13;
	instance_property, &#13;
	property_rules: list&lt;instance_map_rule&gt;&#13;
): gtv? {&#13;
		when (instance_property_type(instance_property)) {&#13;
		property_type.integer -&gt; &#13;
			return _get_property_integer(instance_property)?.to_gtv();&#13;
		property_type.text -&gt;&#13;
			return _get_property_text(instance_property)?.to_gtv();&#13;
		property_type.byte_array -&gt; &#13;
			return _get_property_byte_array(instance_property)?.to_gtv();&#13;
		property_type.boolean -&gt;&#13;
			return _get_property_boolean(instance_property)?.to_gtv();&#13;
		property_type.id -&gt;&#13;
			return _get_property_id(instance_property).to_gtv();&#13;
		property_type.indx -&gt;&#13;
			return _get_property_index(instance_property).to_gtv();&#13;
		property_type.account -&gt; &#13;
			return _get_property_account_serialized(instance_property);&#13;
		property_type._enum -&gt;&#13;
			return _get_property_enum_serialized(instance_property);&#13;
		property_type.interface,&#13;
		property_type.structure -&gt;&#13;
			return _get_property_instance_serialized_with_rules(&#13;
				instance_property, &#13;
				property_rules&#13;
			);&#13;
	}&#13;
}&#13;
&#13;
function set_properties(instance, properties: map&lt;name, gtv&gt;) {&#13;
	for ((name, value) in properties) {&#13;
		set_property(instance, name, value);&#13;
	}&#13;
}&#13;
&#13;
function unset_instance_property(instance, name) {&#13;
	val property = instance_property @ {&#13;
		instance,&#13;
		.structure_property.name == name&#13;
	};&#13;
	&#13;
	require(&#13;
		is_instance_property_readonly(property) == false,&#13;
		"Trying to unset readonly property '" + name + "'"&#13;
	);&#13;
	&#13;
	require(&#13;
		is_instance_property_optional(property) == true,&#13;
		"Trying to unset non-optional property '" + name + "'"&#13;
	);&#13;
	&#13;
	when(property.structure_property.type) {&#13;
		property_type.integer -&gt; &#13;
			_unset_instance_property_integer(property);&#13;
		property_type.text -&gt; &#13;
			_unset_instance_property_text(property);&#13;
		property_type.byte_array -&gt; &#13;
			_unset_instance_property_byte_array(property);&#13;
		property_type.boolean -&gt;&#13;
			_unset_instance_property_boolean(property);&#13;
	}&#13;
}&#13;
&#13;
/*&#13;
 * Query functions&#13;
 */&#13;
&#13;
function get_first(structure, where): instance? {&#13;
	return find_one(structure, where.name, where.value);&#13;
}&#13;
&#13;
function get_all(structure, where): list&lt;instance&gt; {&#13;
	return find_all(structure, where.name, where.value);&#13;
}&#13;
&#13;
function find_by_id(id: byte_array): instance? {&#13;
	return (&#13;
		i: instance, &#13;
		ip: instance_property, &#13;
		ipvi: instance_property_value_id&#13;
	) @? { &#13;
		ipvi.value == id,&#13;
		ipvi.instance_property == ip,&#13;
		ip.instance == i&#13;
	} ( i );&#13;
}&#13;
&#13;
function find_one(structure, property_name: text, value: gtv): instance? {&#13;
	val type = structure_property @ { structure, property_name }.type;&#13;
	&#13;
	when (type) {&#13;
		property_type.id -&gt;&#13;
			return find_one_id(structure, property_name, byte_array.from_gtv(value));&#13;
		property_type.integer -&gt; &#13;
			return find_one_integer(structure, property_name, integer.from_gtv(value));&#13;
		property_type.text -&gt; &#13;
			return find_one_text(structure, property_name, text.from_gtv(value));&#13;
		property_type.indx -&gt; &#13;
			return find_one_index(structure, property_name, integer.from_gtv(value));&#13;
		property_type.byte_array -&gt; &#13;
			return find_one_byte_array(structure, property_name, byte_array.from_gtv(value));&#13;
		property_type.boolean -&gt;&#13;
			return find_one_boolean(structure, property_name, boolean.from_gtv(value));&#13;
		property_type._enum -&gt; &#13;
			return find_one_enum(structure, property_name, enum_value.from_gtv(value));&#13;
		property_type.account -&gt;&#13;
			return find_one_account(structure, property_name, ft3.account.from_gtv(value));&#13;
		property_type.structure,&#13;
		property_type.interface -&gt;&#13;
			return find_one_instance(structure, property_name, instance.from_gtv(value));&#13;
	}&#13;
}&#13;
&#13;
function find_all(structure, property_name: text, value: gtv): list&lt;instance&gt; {&#13;
	val type = structure_property @ { structure, property_name }.type;&#13;
	&#13;
	when (type) {&#13;
		property_type.id -&gt;&#13;
			return find_all_id(structure, property_name, byte_array.from_gtv(value));&#13;
		property_type.integer -&gt; &#13;
			return find_all_integer(structure, property_name, integer.from_gtv(value));&#13;
		property_type.text -&gt; &#13;
			return find_all_text(structure, property_name, text.from_gtv(value));&#13;
		property_type.indx -&gt; &#13;
			return find_all_index(structure, property_name, integer.from_gtv(value));	&#13;
		property_type.byte_array -&gt; &#13;
			return find_all_byte_array(structure, property_name, byte_array.from_gtv(value));&#13;
		property_type.boolean -&gt;&#13;
			return find_all_boolean(structure, property_name, boolean.from_gtv(value));&#13;
		property_type._enum -&gt; &#13;
			return find_all_enum(structure, property_name, enum_value.from_gtv(value));&#13;
		property_type.account -&gt;&#13;
			return find_all_account(structure, property_name, ft3.account.from_gtv(value));&#13;
		property_type.interface,&#13;
		property_type.structure -&gt;&#13;
			return find_all_instance(structure, property_name, instance.from_gtv(value));&#13;
	}&#13;
}&#13;
&#13;
/*&#13;
 * Private functions&#13;
 */&#13;
&#13;
function _create_properties(instance, init) {&#13;
	val properties = structure_property @* {&#13;
		instance.structure&#13;
	};&#13;
	&#13;
	for (property in properties) {&#13;
		val instance_property = create instance_property(&#13;
			instance,&#13;
			property&#13;
		);&#13;
		&#13;
		val init_value = &#13;
			if (init.properties.contains(property.name))&#13;
				init.properties[property.name] &#13;
			else &#13;
				null;&#13;
			&#13;
		_initialze_property(instance_property, init_value);&#13;
	}&#13;
}&#13;
&#13;
function _initialze_property(instance_property, init_value: gtv?) {&#13;
	when (instance_property_type(instance_property)) {&#13;
		property_type.integer -&gt; &#13;
			_initialize_integer_property(instance_property, init_value);&#13;
		property_type.text -&gt; &#13;
			_initialize_text_property(instance_property, init_value);&#13;
		property_type.indx -&gt; &#13;
			_initialize_index_property(instance_property, null);&#13;
		property_type.byte_array -&gt; &#13;
			_initialize_byte_array_property(instance_property, init_value);&#13;
		property_type.structure,&#13;
		property_type.interface -&gt; &#13;
			_initialize_instance_property(instance_property, init_value);&#13;
		property_type.account -&gt; &#13;
			_initialize_ft3_account_property(instance_property, init_value);&#13;
		property_type.boolean -&gt; &#13;
			_initialize_boolean_property(instance_property, init_value);&#13;
		property_type.id -&gt;&#13;
			_initialize_id_property(instance_property, init_value);&#13;
		property_type._enum -&gt;&#13;
			_initialize_enum_property(instance_property, init_value);&#13;
	}&#13;
}&#13;
&#13;
function find_instance_properties_by_meta_tag(&#13;
	instance, &#13;
	tag_name: name&#13;
): list&lt;instance_property&gt; {&#13;
	return (&#13;
		ip: instance_property, &#13;
		spmt: structure_property_meta_tag&#13;
	) @* {&#13;
		ip.instance == instance,&#13;
		spmt.structure_property == ip.structure_property,&#13;
		spmt.name == tag_name&#13;
	} (&#13;
		ip&#13;
	);&#13;
}&#13;
&#13;
function find_static_properties_by_meta_tag(&#13;
	structure, &#13;
	tag_name: name&#13;
): list&lt;static_property&gt; {&#13;
	return (&#13;
		sp: static_property, &#13;
		spmt: static_property_meta_tag&#13;
	) @* {&#13;
		sp.structure == structure,&#13;
		spmt.static_property == sp,&#13;
		spmt.name == tag_name&#13;
	} (&#13;
		sp&#13;
	);&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/instance/mapper.rell">
                                <string>&#13;
enum mapper_type {&#13;
	struct_details,&#13;
	interface_props,&#13;
	interface,&#13;
	property_list,&#13;
	meta_tag,&#13;
	all_properties,&#13;
	tx_history,&#13;
	achievements,&#13;
	instance_count&#13;
}&#13;
&#13;
enum mapper_property_type {&#13;
	direct,&#13;
	array,&#13;
	dict&#13;
}&#13;
&#13;
function to_list(name): map_property_type {&#13;
	return map_property_type(&#13;
		mapper_property_type.array,&#13;
		name		&#13;
	);&#13;
}&#13;
&#13;
function to_map(name): map_property_type {&#13;
	return map_property_type(&#13;
		mapper_property_type.dict,&#13;
		name		&#13;
	);&#13;
}&#13;
&#13;
function direct(): map_property_type {&#13;
	return map_property_type(&#13;
		mapper_property_type.direct,&#13;
		""		&#13;
	);&#13;
}&#13;
&#13;
function interfaces(interface_names: list&lt;name&gt;): map_type {&#13;
	return map_type(&#13;
		mapper_type.interface,&#13;
		interface_names		&#13;
	);&#13;
}&#13;
&#13;
function struct_details(): map_type {&#13;
	return map_type(&#13;
		mapper_type.struct_details,&#13;
		list&lt;name&gt;()		&#13;
	);&#13;
}&#13;
&#13;
function properties(property_names: list&lt;name&gt;): map_type {&#13;
	return map_type(&#13;
		mapper_type.property_list,&#13;
		property_names	&#13;
	);&#13;
}&#13;
&#13;
function all_properties(): map_type {&#13;
	return map_type(&#13;
		mapper_type.all_properties,&#13;
		list&lt;name&gt;()&#13;
	);&#13;
}&#13;
&#13;
function meta_tags(meta_tags: list&lt;name&gt;): map_type {&#13;
	return map_type(&#13;
		mapper_type.meta_tag,&#13;
		meta_tags&#13;
	);&#13;
}&#13;
&#13;
function interface_props(interface_names: list&lt;name&gt;): map_type {&#13;
	return map_type(&#13;
		mapper_type.interface_props,&#13;
		interface_names&#13;
	);&#13;
}&#13;
&#13;
function instance_count(): map_type {&#13;
	return map_type(&#13;
		mapper_type.instance_count,&#13;
		list&lt;name&gt;()&#13;
	);&#13;
}&#13;
&#13;
function tx_history(): map_type {&#13;
	return map_type(&#13;
		mapper_type.tx_history,&#13;
		list&lt;name&gt;()&#13;
	);&#13;
}&#13;
&#13;
function achievements(): map_type {&#13;
	return map_type(&#13;
		mapper_type.achievements,&#13;
		list&lt;name&gt;()&#13;
	);&#13;
}&#13;
&#13;
struct map_ {&#13;
	map_type;&#13;
	map_property_type;&#13;
}&#13;
&#13;
struct map_type {&#13;
	type: mapper_type;&#13;
	names: list&lt;name&gt;;&#13;
}&#13;
&#13;
struct map_property_type {&#13;
	type: mapper_property_type;&#13;
	name;&#13;
}&#13;
&#13;
struct instance_type {&#13;
	type: text;&#13;
	t: gtv;&#13;
}&#13;
&#13;
struct instance_map_rule {&#13;
	instance_type;&#13;
	rules: list&lt;map_&gt;;&#13;
}&#13;
&#13;
function structure_type(structure, definitions: list&lt;map_&gt;): instance_map_rule {&#13;
	return instance_map_rule(&#13;
		instance_type(&#13;
			type = "structure",&#13;
			t = structure.to_gtv()&#13;
		),&#13;
		definitions&#13;
	);&#13;
}&#13;
&#13;
function interface_type(interface, definitions: list&lt;map_&gt;): instance_map_rule {&#13;
	return instance_map_rule(&#13;
		instance_type(&#13;
			type = "interface",&#13;
			t = interface.to_gtv()&#13;
		),&#13;
		definitions&#13;
	);&#13;
}&#13;
&#13;
function all(): list&lt;instance_map_rule&gt; {&#13;
	return list&lt;instance_map_rule&gt;();&#13;
}&#13;
&#13;
function map_instance(instance, map_definitions: list&lt;map_&gt;, rules: list&lt;instance_map_rule&gt;): map&lt;text, gtv?&gt; {&#13;
	val instance_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (map_definition in map_definitions) {&#13;
		val m: map&lt;name, gtv?&gt;;&#13;
		&#13;
		when (map_definition.map_type.type) {&#13;
			mapper_type.interface -&gt; &#13;
				m = _handle_interface_mapping(instance, map_definition.map_type);&#13;
			mapper_type.property_list -&gt;&#13;
				m = _handle_property_list_mapping(instance, map_definition.map_type, rules);&#13;
			mapper_type.meta_tag -&gt;&#13;
				m = _handle_meta_tag_mapping(instance, map_definition.map_type);&#13;
			mapper_type.struct_details -&gt;&#13;
				m = _handle_struct_details_mapping(instance, map_definition.map_type);&#13;
			mapper_type.interface_props -&gt; &#13;
				m = _handle_interface_props_mapping(instance, map_definition.map_type, rules);&#13;
			mapper_type.all_properties -&gt;&#13;
				m = _handle_all_properties_mapping(instance, map_definition.map_type, rules);&#13;
			mapper_type.tx_history -&gt; &#13;
				m = _handle_tx_history_mapping(instance, map_definition.map_type);&#13;
			mapper_type.achievements -&gt;&#13;
				m = _handle_achievements_mapping(instance);&#13;
			else -&gt; {&#13;
				throw("Mapping '" + map_definition.map_type.type.name + "' not implemented");&#13;
				m = map&lt;name, gtv?&gt;(); // never executed. added to &#13;
			}&#13;
				&#13;
		}&#13;
		&#13;
		when (map_definition.map_property_type.type) {&#13;
			mapper_property_type.direct -&gt; &#13;
				instance_map.put_all(m);&#13;
			mapper_property_type.dict -&gt;&#13;
				instance_map[map_definition.map_property_type.name] &#13;
					= m.to_gtv();&#13;
			mapper_property_type.array -&gt;&#13;
				instance_map[map_definition.map_property_type.name] &#13;
					= _dict_to_array(m).to_gtv();&#13;
		}&#13;
	}&#13;
	&#13;
	return instance_map;&#13;
}&#13;
&#13;
function _handle_property_list_mapping(instance, map_type, rules: list&lt;instance_map_rule&gt;): map&lt;name, gtv?&gt; {&#13;
	require(map_type.type == mapper_type.property_list); //TODO: Add error message&#13;
	&#13;
	val property_map = map&lt;name, gtv?&gt;();&#13;
	&#13;
	for (property_name in map_type.names) {&#13;
		val instance_property = _instance_property(instance, property_name);&#13;
		property_map[property_name] = _get_property_serialized_with_rules(instance_property, rules);&#13;
	}&#13;
	&#13;
	return property_map;&#13;
}&#13;
&#13;
function _handle_interface_mapping(instance, map_type): map&lt;name, gtv?&gt; {&#13;
	require(map_type.type == mapper_type.interface); //TODO: Add error message&#13;
	&#13;
	val interfaces = Interfaces(map_type.names);&#13;
	val instance_properties = _get_instance_properties_of_interfaces(instance, interfaces);&#13;
	val static_properties = _get_static_properties_of_interfaces(instance.structure, interfaces);&#13;
	&#13;
	val property_map = map&lt;name, gtv?&gt;();&#13;
	property_map.put_all(_get_instance_property_values(instance_properties.sorted()));&#13;
	property_map.put_all(_get_static_property_values(static_properties));&#13;
	return property_map;&#13;
}&#13;
&#13;
function _handle_interface_props_mapping(instance, map_type, rules: list&lt;instance_map_rule&gt;): map&lt;name, gtv?&gt; {&#13;
	require(map_type.type == mapper_type.interface_props); //TODO: Add error message&#13;
	&#13;
	val interfaces = Interfaces(map_type.names);&#13;
	val instance_properties = _get_instance_properties_of_interface_types(instance, interfaces);&#13;
	&#13;
	val properties_map = map&lt;name, gtv?&gt;();&#13;
	&#13;
	for (instance_property in instance_properties) {&#13;
		val serialized_instance = _get_property_instance_serialized_with_rules(instance_property, rules);&#13;
		&#13;
		if (serialized_instance??) {&#13;
			properties_map[instance_property_name(instance_property)] = serialized_instance;&#13;
		}&#13;
	}&#13;
	&#13;
	return properties_map;&#13;
}&#13;
&#13;
function _handle_meta_tag_mapping(instance, map_type): map&lt;name, gtv?&gt; {&#13;
	require(map_type.type == mapper_type.meta_tag); //TODO: Add error message&#13;
	val instance_properties = find_instance_properties_by_meta_tag(instance, map_type.names[0]);&#13;
	val static_properties = find_static_properties_by_meta_tag(instance.structure, map_type.names[0]);&#13;
	&#13;
	val property_values = map&lt;name, gtv?&gt;();&#13;
	property_values.put_all(_get_instance_property_values(instance_properties));&#13;
	property_values.put_all(_get_static_property_values(static_properties));&#13;
	return property_values;&#13;
}&#13;
&#13;
function _handle_struct_details_mapping(instance, map_type): map&lt;name, gtv?&gt; {&#13;
	require(map_type.type == mapper_type.struct_details); //TODO: Add error message&#13;
	return instance_structure_info(instance);&#13;
}&#13;
&#13;
function _handle_all_properties_mapping(&#13;
	instance, &#13;
	map_type, &#13;
	rules: list&lt;instance_map_rule&gt;&#13;
): map&lt;name, gtv?&gt; {&#13;
	require(map_type.type == mapper_type.all_properties);&#13;
	&#13;
	val properties = instance_property @* { instance }; &#13;
	&#13;
	val properties_map = map&lt;name, gtv?&gt;();&#13;
	for (property in properties) {&#13;
		properties_map[instance_property_name(property)] = &#13;
			_get_property_serialized_with_rules(property, rules);&#13;
	}&#13;
	return properties_map;&#13;
}&#13;
&#13;
function _handle_tx_history_mapping(instance, map_type): map&lt;name, gtv?&gt; {&#13;
	require(map_type.type == mapper_type.tx_history);&#13;
	&#13;
	val trade_events = original.find_original_trade_events(instance);&#13;
	&#13;
	val trade_events_map = map&lt;name, gtv?&gt;();&#13;
	&#13;
	for (i in range(trade_events.size())) {&#13;
		trade_events_map[i.to_text()] = trade_events[i].to_gtv_pretty();&#13;
	}&#13;
	&#13;
	return trade_events_map;&#13;
}&#13;
&#13;
function _handle_achievements_mapping(instance): map&lt;name, gtv?&gt; {&#13;
	val achievements = original.instance_achievements(instance);&#13;
	&#13;
	val achievements_map = map&lt;name, gtv?&gt;();&#13;
	for (i in range(achievements.size())) {&#13;
		achievements_map[i.to_text()] = achievements[i].to_gtv_pretty();&#13;
	}&#13;
	return achievements_map;&#13;
}&#13;
&#13;
function _get_instance_property_values(instance_properties: list&lt;instance_property&gt;): map&lt;name, gtv?&gt; {&#13;
	val properties_map = map&lt;name, gtv?&gt;();&#13;
	for (property in instance_properties) {&#13;
		properties_map[instance_property_name(property)] = _get_property_serialized(property);&#13;
	}&#13;
	return properties_map;&#13;
}&#13;
&#13;
function _get_static_property_values(static_properties: list&lt;static_property&gt;): map&lt;name, gtv?&gt; {&#13;
	val properties_map = map&lt;name, gtv?&gt;();&#13;
	for (property in static_properties) {&#13;
		properties_map[property.name] = _get_static_property_serialized(property);&#13;
	}&#13;
	return properties_map;&#13;
}&#13;
&#13;
function _dict_to_array(dict: map&lt;name, gtv?&gt;): list&lt;gtv?&gt; {&#13;
	val values = list&lt;gtv?&gt;();&#13;
	for ((_, value) in dict) {&#13;
		values.add(value);&#13;
	}&#13;
	return values;&#13;
}&#13;
&#13;
function _mapping_rules(instance, rules: list&lt;instance_map_rule&gt;): list&lt;map_&gt; {&#13;
	for (rule in rules) {&#13;
		when (rule.instance_type.type) {&#13;
			"structure" -&gt; {&#13;
				//TODO: check why strucutre.from_gtv() doesn't work&#13;
				val s = structure @ { rowid.from_gtv(rule.instance_type.t) };&#13;
				if (s == instance.structure) {&#13;
					return rule.rules;&#13;
				}&#13;
			}&#13;
			"interface" -&gt; {&#13;
				val interface = interface.from_gtv(rule.instance_type.t);&#13;
				if (structure_implements_interface(instance.structure, interface)) {&#13;
					return rule.rules;&#13;
				}&#13;
			}&#13;
			else -&gt; {&#13;
				throw("unknown instance type");&#13;
			}&#13;
				&#13;
		}&#13;
	}&#13;
	&#13;
	return [map_(all_properties(), direct())];&#13;
}&#13;
&#13;
&#13;
function _instance_to_primitive_values_map(instance): map&lt;name, gtv?&gt; {&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	property_value_map.put_all(instance_values_integer(instance));&#13;
	property_value_map.put_all(instance_values_text(instance));&#13;
	property_value_map.put_all(instance_values_byte_array(instance));&#13;
	property_value_map.put_all(instance_values_index(instance));&#13;
	property_value_map.put_all(instance_values_boolean(instance));&#13;
	property_value_map.put_all(instances_values_account(instance));&#13;
	property_value_map.put_all(instance_value_id(instance));&#13;
	return property_value_map;&#13;
}&#13;
&#13;
&#13;
function instance_structure_info(instance): map&lt;text, gtv?&gt; {&#13;
	val structure_info = map&lt;text, gtv?&gt;();&#13;
	&#13;
	structure_info["name"] = instance.structure.name.to_gtv();&#13;
	structure_info["implements"] = structure_interface @* { &#13;
		instance.structure,&#13;
		.direct == true&#13;
	} ( .interface.name ).to_gtv();&#13;
	&#13;
	return structure_info;&#13;
}&#13;
&#13;
function instance_values_integer(instance): map&lt;text, gtv?&gt; {&#13;
	val properties = instance_property @* { &#13;
		instance, .structure_property.type == property_type.integer&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (property in properties) {&#13;
		val name = instance_property_name(property);&#13;
		property_value_map[name] = _get_property_integer(property)?.to_gtv(); &#13;
	}&#13;
	&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function instance_values_text(instance): map&lt;text, gtv?&gt; {&#13;
	val properties = instance_property @* { &#13;
		instance, .structure_property.type == property_type.text&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (property in properties) {&#13;
		val name = instance_property_name(property);&#13;
		property_value_map[name] = _get_property_text(property)?.to_gtv(); &#13;
	}&#13;
&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function instance_values_byte_array(instance): map&lt;text, gtv?&gt; {&#13;
	val properties = instance_property @* { &#13;
		instance, .structure_property.type == property_type.byte_array&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (property in properties) {&#13;
		val name = instance_property_name(property);&#13;
		val value = instance_property_value_byte_array @? { property }.value?.to_gtv();&#13;
		property_value_map[name] = value; &#13;
	}&#13;
	&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function instance_values_index(instance): map&lt;text, gtv?&gt; {&#13;
	val properties = instance_property @* { &#13;
		instance, .structure_property.type == property_type.indx&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (property in properties) {&#13;
		val name = instance_property_name(property);&#13;
		val value = instance_property_value_index @? { property }.value?.to_gtv();&#13;
		property_value_map[name] = value; &#13;
	}&#13;
	&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function instance_values_boolean(instance): map&lt;text, gtv?&gt; {&#13;
	val properties = instance_property @* { &#13;
		instance, .structure_property.type == property_type.boolean&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (property in properties) {&#13;
		val name = instance_property_name(property);&#13;
		val value = instance_property_value_boolean @? { property }.value?.to_gtv();&#13;
		property_value_map[name] = value; &#13;
	}&#13;
	&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function instance_value_id(instance): map&lt;text, gtv&gt; {&#13;
	val property = (&#13;
		i: instance, &#13;
		ip: instance_property, &#13;
		ipvi: instance_property_value_id&#13;
	) @? {&#13;
		i == instance,&#13;
		ip.instance == i,&#13;
		ipvi.instance_property == ip&#13;
	} ( ipvi );&#13;
	&#13;
	return &#13;
		if (property??) [&#13;
				property.instance_property.structure_property.name: property.value.to_gtv()&#13;
			]&#13;
		else &#13;
			map&lt;text, gtv&gt;();&#13;
}&#13;
&#13;
function instances_values_account(instance): map&lt;text, gtv?&gt; {&#13;
	val properties = instance_property @* { &#13;
		instance, &#13;
		.structure_property.type == property_type.account &#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (property in properties) {&#13;
		val name = instance_property_name(property);&#13;
		val account = instance_property_value_account @? { property }.value;&#13;
		&#13;
		property_value_map[name] = account?.id?.to_gtv();&#13;
	}&#13;
	&#13;
	return property_value_map;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/instance/private_functions.rell">
                                <string>&#13;
function instance_property_name(instance_property): text {&#13;
	return instance_property.structure_property.name;&#13;
}&#13;
&#13;
function instance_property_type(instance_property): property_type {&#13;
	return instance_property.structure_property.type;&#13;
}&#13;
&#13;
function is_instance_property_readonly(instance_property): boolean {&#13;
	return instance_property.structure_property.readonly;&#13;
}&#13;
&#13;
function is_instance_property_optional(instance_property): boolean {&#13;
	return instance_property.structure_property.optional;&#13;
}&#13;
&#13;
function is_entity(instance): boolean {&#13;
	return instance.structure.is_entity;&#13;
}</string>
                            </entry>
                            <entry key="lib/instance/require_functions.rell">
                                <string>&#13;
function require_instance_property_not_readonly(instance_property) {&#13;
	require(&#13;
		is_instance_property_readonly(instance_property) == false,&#13;
		"Trying to update readonly property '" + &#13;
		instance_property_name(instance_property) + &#13;
		"'"	&#13;
	);&#13;
}&#13;
&#13;
function require_object_property_optional(instance_property) {&#13;
	require(&#13;
		is_instance_property_optional(instance_property),&#13;
		"Trying to unset non-optional property '" + &#13;
		instance_property_name(instance_property) + &#13;
		"'"&#13;
	);&#13;
}&#13;
&#13;
function require_instance_owner(instance, ft3.account) {&#13;
	require(get_property_account(instance, "owner")!! == account);&#13;
}&#13;
&#13;
function require_instance_is_of_valid_type(instance_property, instance) {&#13;
	_require_property_structure_or_interface(instance_property);&#13;
	&#13;
	val name = instance_property_name(instance_property);&#13;
	val type = instance_property_type(instance_property);&#13;
	&#13;
	when(type) {&#13;
		property_type.interface -&gt; {&#13;
			val interface = structure_property_interface @ { &#13;
				instance_property.structure_property&#13;
			}.interface;&#13;
			&#13;
			require(&#13;
				structure_implements_interface(instance.structure, interface),&#13;
				"Property '" + name + "' is not of '" + interface.name + "' type."&#13;
			);&#13;
		}&#13;
		property_type.structure -&gt; {&#13;
			val structure = structure_property_structure @ { &#13;
				instance_property.structure_property&#13;
			}.structure;&#13;
			&#13;
			require(&#13;
				instance.structure == structure,&#13;
				"Property '" + name + "' is not of '" + structure.name + "' type."&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function _require_property_structure_or_interface(instance_property) {&#13;
	val name = instance_property_name(instance_property);&#13;
	val type = instance_property_type(instance_property);&#13;
&#13;
	require(&#13;
		type == property_type.structure or type == property_type.interface,&#13;
		"Property '" + name + "' is not an interface or a structure"&#13;
	);&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/instance/text.rell">
                                <string>entity instance_property_value_text {&#13;
	key instance_property;&#13;
	mutable value: text;&#13;
}&#13;
&#13;
/* &#13;
 * Get &amp; Set functions&#13;
 */&#13;
 &#13;
function set_property_text(instance, path: text, value: text) {&#13;
	_set_property_text(_instance_property_of_path(instance, path), value);&#13;
}&#13;
 &#13;
function _set_property_text(instance_property, value: text) {&#13;
	require_instance_property_not_readonly(instance_property);&#13;
	val property_value = instance_property_value_text @? { instance_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create instance_property_value_text(&#13;
			instance_property,&#13;
			value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_property_text(instance, path: text): text? {&#13;
	return _get_property_text(_instance_property_of_path(instance, path));&#13;
}&#13;
&#13;
function _get_property_text(instance_property): text? {&#13;
	require(&#13;
		instance_property_type(instance_property) == property_type.text&#13;
	);&#13;
	&#13;
	return instance_property_value_text @? { instance_property }?.value;&#13;
}&#13;
&#13;
function _unset_instance_property_text(instance_property) {	&#13;
	delete instance_property_value_text @? {&#13;
		instance_property&#13;
	};&#13;
}&#13;
&#13;
/*&#13;
 * Query functions&#13;
 */&#13;
&#13;
function find_one_text(structure, property_name: text, value: text): instance? {&#13;
	val instances = instance_property_value_text @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance ) limit 1;&#13;
	&#13;
	return if (instances.size() &gt; 0) instances[0] else null;&#13;
}&#13;
&#13;
function find_all_text(structure, property_name: text, value: text): list&lt;instance&gt; {&#13;
	return instance_property_value_text @* {&#13;
		.instance_property.instance.structure == structure,&#13;
		.instance_property.structure_property.name == property_name,&#13;
		.value == value&#13;
	} ( .instance_property.instance );&#13;
}&#13;
&#13;
/*&#13;
 * Initialization&#13;
 */&#13;
&#13;
function _initialize_text_property(instance_property, init_value: gtv?) {&#13;
	val prop = instance_property.structure_property;&#13;
	&#13;
	val init_value_text = &#13;
		if (init_value??) &#13;
			text.from_gtv(init_value) &#13;
		else &#13;
			null;&#13;
	&#13;
	val default_value = &#13;
		if (instance_property.structure_property.value.size() != 0) &#13;
			text.from_gtv(gtv.from_bytes(instance_property.structure_property.value)) &#13;
		else &#13;
			null;&#13;
&#13;
	require(&#13;
		default_value != null or init_value_text != null or prop.optional == true,&#13;
		"Non-optional text property '" + prop.name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly == false&#13;
			or&#13;
		((default_value == null or init_value_text == null) and prop.readonly == true),&#13;
		"Readonly text property '" + prop.name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_text ?: default_value;&#13;
	&#13;
	if (v??) {&#13;
		create instance_property_value_text(&#13;
			instance_property,&#13;
			v&#13;
		);&#13;
	}&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/interface/definition.rell">
                                <string>&#13;
enum optional_key {&#13;
	optional,&#13;
	non_optional,&#13;
	all&#13;
}&#13;
&#13;
enum static_key {&#13;
	static,&#13;
	non_static,&#13;
	all&#13;
}&#13;
&#13;
struct id_config {&#13;
	static: static_key = static_key.all;&#13;
	optional: optional_key = optional_key.all;&#13;
	meta: boolean = false;&#13;
	tags: list&lt;name&gt; = list&lt;name&gt;();&#13;
	interface_meta: boolean = false;&#13;
	interface_tags: list&lt;name&gt; = list&lt;name&gt;();&#13;
}&#13;
&#13;
function interface_definition(interface, id_config): map&lt;name, gtv&gt; {&#13;
	val definition = map&lt;name, gtv&gt;();&#13;
	definition["name"] = interface.name.to_gtv();&#13;
	definition["properties"] = __interface.property_definitions(interface, id_config).to_gtv();&#13;
	&#13;
	if (id_config.interface_meta or id_config.interface_tags.size() &gt; 0) {&#13;
		definition["meta"] = __interface.meta(interface, id_config.interface_tags).to_gtv();&#13;
	}&#13;
	&#13;
	return definition;&#13;
}&#13;
&#13;
namespace __interface {&#13;
	function meta(interface, tags: list&lt;name&gt;): map&lt;name, text?&gt; {&#13;
		val meta_tags_map = map&lt;name, text?&gt;();&#13;
		&#13;
		if (tags.size() == 0) {&#13;
			val interface_tags = interface_meta_tag @* { interface };&#13;
			for (tag in interface_tags) {&#13;
				meta_tags_map[tag.name] = tag.value;&#13;
			}&#13;
		} else {&#13;
			for (tag in tags) {&#13;
				val interface_tag = interface_meta_tag @? { interface, .name == tag };&#13;
				if (interface_tag??) {&#13;
					meta_tags_map[tag] = interface_tag.value;&#13;
				}&#13;
			}&#13;
		}&#13;
		&#13;
		return meta_tags_map;&#13;
	}&#13;
	&#13;
	function property_definitions(interface, id_config): map&lt;name, gtv&gt; {&#13;
		val properties = _get_interface_all_properties(interface);&#13;
		val properties_map = map&lt;name, gtv&gt;();&#13;
		for (property in properties) {&#13;
			if (&#13;
				fulfils_static_rule(property, id_config)&#13;
					and&#13;
				fulfils_optional_rule(property, id_config)&#13;
			) {&#13;
				properties_map[property.name] &#13;
					= property_definition(property, id_config).to_gtv();&#13;
			}&#13;
		}&#13;
		return properties_map;&#13;
	}&#13;
	&#13;
	function property_definition(interface_property, id_config): map&lt;name, gtv&gt; {&#13;
		val property_definition_map = map&lt;name, gtv&gt;();&#13;
		property_definition_map["type"] &#13;
			= property_type(interface_property).to_gtv();&#13;
		if (id_config.static == static_key.all) {&#13;
			property_definition_map["static"] &#13;
				= interface_property.static.to_gtv();&#13;
		}&#13;
		if (id_config.meta or id_config.tags.size() &gt; 0) {&#13;
			property_definition_map["meta"] &#13;
				= property_meta(interface_property, id_config.tags).to_gtv();&#13;
		}&#13;
		if (id_config.optional == optional_key.all) {&#13;
			property_definition_map["optional"] = interface_property.optional.to_gtv();&#13;
		}&#13;
		&#13;
		return property_definition_map;&#13;
	}&#13;
	&#13;
	function property_type(interface_property): name {&#13;
		val prop = prop.from_bytes(interface_property.encoded_prop);&#13;
		when (interface_property.type) {&#13;
			property_type.interface -&gt; {&#13;
				val interface_prop = inf.from_gtv(prop.prop_type_struct.type_gtv);&#13;
				return interface_prop.interface.name;&#13;
			}&#13;
			property_type.structure -&gt; {&#13;
				val structure_prop = strct.from_gtv(prop.prop_type_struct.type_gtv);&#13;
				return structure_prop.structure.name;&#13;
			}&#13;
			else -&gt; {&#13;
				val type = interface_property.type;&#13;
				return type.name;&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	function property_meta(interface_property, tags: list&lt;name&gt;): map&lt;name, gtv&gt; {&#13;
		val meta_tags_map = map&lt;name, gtv&gt;();&#13;
		&#13;
		if (tags.size() == 0) {&#13;
			val meta_tags = interface_property_meta_tag @* { interface_property };&#13;
			&#13;
			for (tag in meta_tags) {&#13;
				meta_tags_map[tag.name] = tag.value.to_gtv();&#13;
			}&#13;
		} else {&#13;
			for (tag in tags) {&#13;
				val meta_tag = interface_property_meta_tag @? { interface_property, .name == tag };&#13;
				&#13;
				if (meta_tag??) {&#13;
					meta_tags_map[meta_tag.name] = meta_tag.value.to_gtv();&#13;
				}&#13;
			}&#13;
		}&#13;
		&#13;
		return meta_tags_map;&#13;
	}&#13;
	&#13;
	function fulfils_static_rule(interface_property, id_config): boolean {&#13;
		return&#13;
			(interface_property.static and id_config.static != static_key.non_static) &#13;
				or &#13;
			(not interface_property.static and id_config.static != static_key.static);&#13;
	}&#13;
	&#13;
	function fulfils_optional_rule(interface_property, id_config): boolean {&#13;
		return&#13;
			(interface_property.optional and id_config.optional != optional_key.non_optional) &#13;
				or &#13;
			(not interface_property.optional and id_config.optional != optional_key.optional);&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/interface/interface.rell">
                                <string>import ^.component_definition.*;&#13;
&#13;
entity interface {&#13;
	key name: text, brid;&#13;
	brid: byte_array;&#13;
	mutable description: text;&#13;
}&#13;
&#13;
entity extended_interface {&#13;
	index extended;&#13;
	key extended, base;&#13;
	extended: interface;&#13;
	base: interface;&#13;
	direct: boolean;&#13;
}&#13;
&#13;
entity interface_property {&#13;
	index interface;&#13;
	key name, interface;&#13;
	name: text;&#13;
	type: property_type;&#13;
	readonly: boolean;&#13;
	optional: boolean;&#13;
	static: boolean;&#13;
	encoded_prop: byte_array;&#13;
}&#13;
&#13;
entity interface_meta_tag {&#13;
	index interface;&#13;
	key interface, name;&#13;
	value: text;&#13;
}&#13;
&#13;
entity interface_property_meta_tag {&#13;
	index interface_property;&#13;
	key interface_property, name;&#13;
	value: text;&#13;
}&#13;
&#13;
entity interface_property_meta {&#13;
	index interface_property;&#13;
	key interface_property, name;&#13;
	value: text;&#13;
}&#13;
&#13;
struct interface_ {&#13;
	name;&#13;
	description = description("");&#13;
	extends = extends(list&lt;interface&gt;());&#13;
	chain = chain(chain_context.blockchain_rid);&#13;
	properties: map&lt;text, prop&gt; = map&lt;text, prop&gt;();&#13;
	meta = meta(list&lt;tag&gt;());&#13;
}&#13;
&#13;
struct extends {&#13;
	interfaces: list&lt;interface&gt; = list&lt;interface&gt;();&#13;
}&#13;
&#13;
function defI(interface_): interface {&#13;
	return create_interface(&#13;
		interface_.name, &#13;
		interface_.chain.id, &#13;
		interface_.description.value, &#13;
		interface_.properties,&#13;
		interface_.extends.interfaces,&#13;
		interface_.meta&#13;
	);&#13;
}&#13;
&#13;
function Interface(name): interface {&#13;
	return get_interface_by_name(name);&#13;
}&#13;
&#13;
function Interfaces(names: list&lt;name&gt;): list&lt;interface&gt; {&#13;
	return get_interfaces_by_names(names);&#13;
}&#13;
&#13;
function create_interface(&#13;
	name, brid: byte_array, &#13;
	description: text, &#13;
	properties: map&lt;name, prop&gt;, &#13;
	extends: list&lt;interface&gt;,&#13;
	meta: meta&#13;
): interface {&#13;
	val inf = create interface(&#13;
		name = name,&#13;
		brid = brid,&#13;
		description = description&#13;
	);&#13;
	&#13;
	val extended_interfaces = set&lt;interface&gt;();&#13;
	&#13;
	for (interface in extends) {&#13;
		create extended_interface(&#13;
			extended = inf,&#13;
			base = interface,&#13;
			direct = true&#13;
		);&#13;
		&#13;
		extended_interfaces.add(interface);&#13;
		&#13;
		for (ext_interface in interface_extended_interfaces(interface)) {&#13;
			if (not extended_interfaces.contains(ext_interface)) {&#13;
				create extended_interface(&#13;
					extended = inf,&#13;
					base = ext_interface,&#13;
					direct = false&#13;
				);&#13;
				&#13;
				extended_interfaces.add(ext_interface);&#13;
			}			&#13;
		}&#13;
	}&#13;
	&#13;
	for ((prop_name, property) in properties) {&#13;
		val p = create interface_property(&#13;
			inf,&#13;
			prop_name,&#13;
			type = property.prop_type_struct.type,&#13;
			readonly = property.readonly.value,&#13;
			optional = property.optional.value,&#13;
			static = property.static.value,&#13;
			encoded_prop = property.to_bytes()&#13;
		);&#13;
		&#13;
		_create_interface_property_meta_tags(p, property.meta.tags);&#13;
	}&#13;
	&#13;
	for (tag in meta.tags) {&#13;
		create interface_meta_tag(&#13;
			inf,&#13;
			name = tag.name,&#13;
			value = tag.value.value&#13;
		);		&#13;
	}&#13;
	&#13;
	return inf;&#13;
}&#13;
&#13;
function get_interfaces_by_names(interfaces_names: list&lt;text&gt;): list&lt;interface&gt; {&#13;
	var interface_entities = list&lt;interface&gt;();&#13;
	&#13;
	for (interface_name in interfaces_names) {&#13;
		val interface = interface @ { .name == interface_name };&#13;
		interface_entities.add(interface);&#13;
	}&#13;
	&#13;
	return interface_entities;&#13;
}&#13;
&#13;
function interface_base_interfaces(interface): list&lt;interface&gt; {&#13;
	return extended_interface @* {&#13;
		.extended == interface,&#13;
		.direct == true&#13;
	}( .base );&#13;
}&#13;
&#13;
function interface_extended_interfaces(interface): list&lt;interface&gt; {&#13;
	return extended_interface @* {&#13;
		.extended == interface&#13;
	}( .base );&#13;
}&#13;
&#13;
function get_interface_by_name(interface_name: text): interface {&#13;
	return interface @ { .name == interface_name, .brid == chain_context.blockchain_rid };&#13;
}&#13;
&#13;
function get_interface_properties(interface_name: text): list&lt;interface_property&gt; {&#13;
	return interface_property @* {&#13;
		.interface == interface @ { .name == interface_name }&#13;
	};&#13;
}&#13;
&#13;
function set_interface_description(interface, description: text) {&#13;
	interface.description = description;&#13;
}&#13;
&#13;
function find_interface_properties_by_meta_tag(&#13;
	interface, &#13;
	tag_name: name&#13;
): list&lt;(property: interface_property, tag: interface_property_meta_tag)&gt; {&#13;
	return (ip: interface_property, ipmt: interface_property_meta_tag) @* {&#13;
		ip.interface == interface,&#13;
		ipmt.interface_property == ip,&#13;
		ipmt.name == tag_name&#13;
	} (&#13;
		property = ip, tag = ipmt&#13;
	);&#13;
}&#13;
&#13;
function _create_interface_property_meta_tag(interface_property, tag): interface_property_meta_tag {&#13;
	return create interface_property_meta_tag(&#13;
		interface_property,&#13;
		name = tag.name,&#13;
		value = tag.value.value&#13;
	);&#13;
}&#13;
&#13;
&#13;
function get_interfaces_extending_interface(interface): list&lt;(interface: name, base: name)&gt; {&#13;
	val indirect_extension = (&#13;
		ei1: extended_interface,&#13;
		ei2: extended_interface&#13;
	) @* {&#13;
		ei1.base == interface,&#13;
		ei2.base == ei1.extended,&#13;
		ei2.direct == true&#13;
	} (&#13;
		interface = ei2.extended.name,&#13;
		base = ei2.base.name&#13;
	);&#13;
	&#13;
	val direct_extension = extended_interface @* { &#13;
		.base == interface,&#13;
		.direct == true&#13;
	} (&#13;
		interface = .extended.name,&#13;
		base = .base.name&#13;
	);&#13;
	&#13;
	val interfaces = set&lt;(interface: name, base: name)&gt;();&#13;
	interfaces.add_all(indirect_extension);&#13;
	interfaces.add_all(direct_extension);&#13;
	&#13;
	return interfaces.sorted();&#13;
}&#13;
&#13;
function _create_interface_property_meta_tags(interface_property, tags: list&lt;tag&gt;) {&#13;
	for (tag in tags) {&#13;
		_create_interface_property_meta_tag(interface_property, tag);&#13;
	}&#13;
}&#13;
&#13;
function require_interface_property_static(interface_property) {&#13;
	require(&#13;
		interface_property.static, &#13;
		"Property '" + interface_property.name + "' is not static"&#13;
	);&#13;
}&#13;
&#13;
function require_interface_property_type(interface_property, property_type) {&#13;
	require(&#13;
		interface_property.type == property_type,&#13;
		"Property '" + interface_property.name + "' is not of type " + property_type&#13;
	);&#13;
}&#13;
&#13;
function _get_interface_all_properties(interface): list&lt;interface_property&gt; {&#13;
	val interface_properties = list&lt;interface_property&gt;();&#13;
	&#13;
	interface_properties.add_all(interface_property @* { interface });&#13;
	interface_properties.add_all((&#13;
		ip: interface_property, &#13;
		ei: extended_interface&#13;
	) @* {&#13;
		ei.extended == interface,&#13;
		ip.interface == ei.base&#13;
	} ( &#13;
		ip&#13;
	));&#13;
	&#13;
	return interface_properties;&#13;
}</string>
                            </entry>
                            <entry key="lib/marketplace/category.rell">
                                <string>&#13;
struct category_node {&#13;
	name;&#13;
	interfaces: list&lt;text&gt;;&#13;
	subcategories: list&lt;category_node&gt;;&#13;
}&#13;
&#13;
&#13;
function _category_node(&#13;
	name, &#13;
	interface_map: map&lt;name, list&lt;name&gt;&gt;, &#13;
	category_names: map&lt;name, name&gt;&#13;
): category_node {&#13;
	val category_nodes = list&lt;category_node&gt;();&#13;
	&#13;
	if (not interface_map.contains(name)) {&#13;
		return category_node(&#13;
			name = if (category_names.contains(name)) category_names[name] else name,&#13;
			interfaces = [name],&#13;
			subcategories = list&lt;category_node&gt;()&#13;
		);&#13;
	}&#13;
	&#13;
	for (child in interface_map[name]) {&#13;
		category_nodes.add(_category_node(child, interface_map, category_names));&#13;
	}&#13;
	&#13;
	return category_node(&#13;
		name = if (category_names.contains(name)) category_names[name] else name,&#13;
		interfaces = [name],&#13;
		subcategories = category_nodes&#13;
	);&#13;
}&#13;
&#13;
function get_categories(): list&lt;category_node&gt; {&#13;
	val ITradeableOriginal = Interface('ITradeableOriginal');&#13;
	&#13;
	val tags = (&#13;
		imt: interface_meta_tag,&#13;
		ei: extended_interface&#13;
	) @* {&#13;
		imt.name == "marketplace_category",&#13;
		imt.interface == ei.extended,&#13;
		ei.base == ITradeableOriginal&#13;
	} (&#13;
		name = imt.value,&#13;
		imt.interface&#13;
	);&#13;
	&#13;
	val category_names = map&lt;name, name&gt;();&#13;
	&#13;
	for ((name, interface) in tags) {&#13;
		category_names[interface.name] = name;&#13;
	}&#13;
	&#13;
	val interfaces = get_interfaces_extending_interface(&#13;
		ITradeableOriginal&#13;
	);&#13;
	&#13;
	val interface_map = map&lt;name, list&lt;name&gt;&gt;();&#13;
	&#13;
	for ((interface, base) in interfaces) {&#13;
		if (interface_map.contains(base)) {&#13;
			interface_map[base].add(interface);&#13;
		} else {&#13;
			interface_map[base] = [interface];&#13;
		}&#13;
	}&#13;
	&#13;
	return _category_node(&#13;
		ITradeableOriginal.name, interface_map, category_names&#13;
	).subcategories;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/marketplace/filter.rell">
                                <string>&#13;
function filter_property(name): tag {&#13;
	return tag("filter-property", value(name));&#13;
}&#13;
&#13;
function get_interface_filters(name, brid: byte_array): map&lt;name, gtv&gt; {&#13;
	val property_tag_pair_list = find_interface_properties_by_meta_tag(Interface(name), "filter-property");&#13;
	val filters_definition = map&lt;name, gtv&gt;();&#13;
	&#13;
	for ((property, tag) in property_tag_pair_list) {&#13;
		when (property.type) {&#13;
			property_type.text -&gt; &#13;
				filters_definition[tag.value] &#13;
					= _handle_text_filter(property).to_gtv();&#13;
			property_type.integer -&gt;&#13;
				filters_definition[tag.value]&#13;
					= _handle_integer_filter(property).to_gtv();&#13;
		}&#13;
	}&#13;
	&#13;
	return filters_definition;&#13;
}&#13;
&#13;
function _options_filter(name, values: list&lt;gtv&gt;): map&lt;text, gtv&gt; {&#13;
	return [&#13;
		"name": name.to_gtv(),&#13;
		"type": "options".to_gtv(),&#13;
		"values": values.to_gtv()&#13;
	];&#13;
}&#13;
&#13;
function _options_filter_text(name, values: list&lt;text&gt;): map&lt;text, gtv&gt; {&#13;
	return _options_filter(&#13;
		name,&#13;
		text_list_to_gtv_list(values)&#13;
	);&#13;
}&#13;
&#13;
function _range_filter(name, min: integer, max: integer): map&lt;text, gtv&gt; {&#13;
	return [&#13;
		"name": name.to_gtv(),&#13;
		"type": "range".to_gtv(),&#13;
		"values": [&#13;
			"min": min.to_gtv(),&#13;
			"max": max.to_gtv()&#13;
		].to_gtv()&#13;
	];&#13;
}&#13;
&#13;
function _handle_text_filter(interface_property): map&lt;name, gtv&gt; {&#13;
	return _options_filter_text(&#13;
		interface_property.name,&#13;
		_get_interface_static_property_values_text(interface_property)&#13;
	);&#13;
}&#13;
&#13;
function _handle_integer_filter(interface_property): map&lt;name, gtv&gt; {&#13;
	val values = _get_interface_static_property_values_integer(interface_property);&#13;
	&#13;
	if (values.size() == 0) return _range_filter(interface_property.name, 0,100);&#13;
	&#13;
	if (values.size() == 1) return _range_filter(interface_property.name, values[0], values[0]);&#13;
	&#13;
	return _range_filter(interface_property.name, values[0], values[values.size()-1]);&#13;
}&#13;
&#13;
function _get_interface_static_property_values_text(interface_property): list&lt;text&gt; {&#13;
	require_interface_property_static(interface_property);&#13;
	require_interface_property_type(interface_property, property_type.text);&#13;
	&#13;
	val values = (&#13;
		sp: static_property,&#13;
		si: structure_interface, &#13;
		spvt: static_property_value_text&#13;
	) @* {&#13;
		si.interface == interface_property.interface,&#13;
		si.structure == sp.structure,&#13;
		sp.name == interface_property.name,&#13;
		spvt.static_property == sp&#13;
	} ( spvt.value );&#13;
	&#13;
	return set&lt;text&gt;(values).sorted();&#13;
}&#13;
&#13;
function _get_interface_static_property_values_integer(interface_property): list&lt;integer&gt; {&#13;
	require_interface_property_static(interface_property);&#13;
	require_interface_property_type(interface_property, property_type.integer);&#13;
&#13;
	val values = (&#13;
		sp: static_property,&#13;
		si: structure_interface, &#13;
		spvi: static_property_value_integer&#13;
	) @* {&#13;
		si.interface == interface_property.interface,&#13;
		si.structure == sp.structure,&#13;
		sp.name == interface_property.name,&#13;
		spvi.static_property == sp&#13;
	} ( spvi.value );&#13;
	&#13;
	return set&lt;integer&gt;(values).sorted();&#13;
}</string>
                            </entry>
                            <entry key="lib/marketplace/functions.rell">
                                <string>import ft3: rell_modules.ft3.account;&#13;
import ft3_core: rell_modules.ft3.core;&#13;
&#13;
struct property_def {&#13;
	name;&#13;
	prop;&#13;
}&#13;
&#13;
function find_originals_by_interface(name, brid: byte_array): list&lt;structure&gt; {	&#13;
	return (si1: structure_interface, si2: structure_interface) @* {&#13;
		si1.interface == Interface("IOriginal"),&#13;
		si2.interface == Interface(name),&#13;
		si1.structure == si2.structure 	&#13;
	} ( si1.structure );&#13;
}&#13;
&#13;
function find_listed_instances_by_interface(&#13;
	name, &#13;
	brid: byte_array, &#13;
	after_rowid: rowid, &#13;
	page_size: integer&#13;
): list&lt;instance&gt; {&#13;
	return (&#13;
		i: instance, &#13;
		ip: instance_property, &#13;
		ipvb: instance_property_value_boolean, &#13;
		si1: structure_interface, &#13;
		si2: structure_interface&#13;
	) @* {&#13;
		si1.interface == Interface("ITradeableOriginal"),&#13;
		si2.interface == Interface(name),&#13;
		si1.structure == si2.structure,&#13;
		i.structure == si1.structure,&#13;
		ip.structure_property.name == "is_listed",&#13;
		ip.instance == i,&#13;
		ipvb.instance_property == ip,&#13;
		ipvb.value == true&#13;
	} ( @sort i ) limit page_size;&#13;
}&#13;
&#13;
function find_originals_by_designer_id(id: byte_array): list&lt;structure&gt; {&#13;
	return (&#13;
		si: structure_interface,&#13;
		sp: static_property,&#13;
		spvb: static_property_value_byte_array &#13;
	) @* {&#13;
		si.interface == Interface("ITradeableOriginal"),&#13;
		sp.structure == si.structure,&#13;
		sp.name == "designer_id",&#13;
		spvb.static_property == sp,&#13;
		spvb.value == id&#13;
	} ( sp.structure );&#13;
}&#13;
&#13;
function find_instances_by_original(original_name: text): list&lt;instance&gt; {	&#13;
	return (i: instance, si: structure_interface) @* {&#13;
		si.structure.name == original_name,&#13;
		si.interface == Interface("IOriginal"),&#13;
		i.structure == si.structure&#13;
	} ( i );&#13;
}&#13;
&#13;
function buy_original_instance(&#13;
	structure_name: name, &#13;
	instance_id: byte_array, &#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	val new_owner = ft3.account @ { account_id };&#13;
	ft3.require_auth(new_owner, auth_descriptor_id, ["T"]);&#13;
	&#13;
	val instance = find_by_id(instance_id)!!;&#13;
	&#13;
	val is_listed = get_property_boolean(instance, "is_listed")!!;&#13;
	require(is_listed, "Original is not for sale");&#13;
	&#13;
	val current_owner = get_property_account(instance, "owner")!!;&#13;
	&#13;
	val price = get_property_integer(instance, "price")!!;&#13;
	val asset_id = get_property_byte_array(instance, "asset_id")!!;&#13;
	&#13;
	val input = ft3_core.xfer_input(&#13;
		account_id = new_owner.id,&#13;
		amount = price,&#13;
		asset_id = asset_id,&#13;
		auth_descriptor_id = auth_descriptor_id,&#13;
		extra = map&lt;text, gtv&gt;()&#13;
	);&#13;
	&#13;
	val output = ft3_core.xfer_output(&#13;
		account_id = current_owner.id,&#13;
		amount = price,&#13;
		asset_id = asset_id,&#13;
		extra = map&lt;text, gtv&gt;()&#13;
	);&#13;
	&#13;
	ft3_core._transfer([input], [output]);&#13;
	&#13;
	val child_original_properties = _get_instance_properties_of_interface_types(&#13;
		instance, &#13;
		[Interface("ITradeableOriginal")]&#13;
	);&#13;
	&#13;
	log_original_event_buy(instance, current_owner, new_owner, asset_id, price);&#13;
	&#13;
	set_property_account(instance, "owner", new_owner);&#13;
	set_property_boolean(instance, "is_listed", false);&#13;
	&#13;
	for (property in child_original_properties) {&#13;
		val child_original = _get_property_instance(property); &#13;
		if (child_original??) {&#13;
			log_original_event_buy(child_original, current_owner, new_owner, asset_id, 0); //TODO: Check which price to set for child assets&#13;
			set_property_account(child_original, "owner", new_owner);&#13;
			set_property_boolean(child_original, "is_listed", false);			&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
struct trade_info {&#13;
	asset_id: byte_array;&#13;
	price: integer;&#13;
	is_listed: boolean;&#13;
}&#13;
&#13;
function set_original_instance_trade_info(&#13;
	structure_name: name, &#13;
	instance_id: byte_array,&#13;
	trade_info,&#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	val account = ft3.account @ { account_id };&#13;
	ft3.require_auth(account, auth_descriptor_id, ["T"]);&#13;
	&#13;
	val instance = find_by_id(instance_id);&#13;
	&#13;
	require(instance??);&#13;
	require_instance_owner(instance!!, account);&#13;
	&#13;
	set_properties(instance, [&#13;
		"is_listed": trade_info.is_listed.to_gtv(),&#13;
		"price": trade_info.price.to_gtv(),&#13;
		"asset_id": trade_info.asset_id.to_gtv()&#13;
	]);&#13;
}&#13;
&#13;
function set_original_instance_sale_status(&#13;
	structure_name: name, &#13;
	instance_id: byte_array, &#13;
	is_listed: boolean,&#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	val account = ft3.account @ { account_id };&#13;
	ft3.require_auth(account, auth_descriptor_id, ["T"]);&#13;
	&#13;
	val instance = find_by_id(instance_id);&#13;
	&#13;
	require(instance??);&#13;
	require_instance_owner(instance!!, account);&#13;
	require(get_property_byte_array(instance, "asset_id")??, "Asset ID not set");&#13;
	require(get_property_integer(instance, "price")??, "Price not set");&#13;
	&#13;
	set_property(instance, "is_listed", is_listed.to_gtv());&#13;
}&#13;
&#13;
function def_structure(&#13;
	structure_name: name, &#13;
	interface_names: list&lt;name&gt;,&#13;
	property_list: list&lt;property&gt;,&#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	val account = ft3.account @ { account_id };&#13;
	ft3.require_auth(account, auth_descriptor_id, ["T"]);&#13;
	&#13;
	val properties = property_list_to_property_map(property_list);&#13;
	&#13;
	if ("designer_id" in properties) {&#13;
		require(&#13;
			byte_array.from_gtv(properties["designer_id"]) == account_id,&#13;
			"Caller account id is not equal to designer id"&#13;
		);		&#13;
	} else {&#13;
		properties["designer_id"] = account_id.to_gtv();&#13;
	}&#13;
	&#13;
	def_(structure_(structure_name, implements(get_interfaces_by_names(interface_names)),&#13;
		init(properties)&#13;
	));&#13;
}&#13;
&#13;
function def_original(&#13;
	structure_name: name, &#13;
	interface_names: list&lt;name&gt;,&#13;
	def_property_list: list&lt;property_def&gt;,&#13;
	init_property_list: list&lt;property&gt;,&#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	val account = ft3.account @ { account_id };&#13;
	ft3.require_auth(account, auth_descriptor_id, ["T"]);&#13;
	&#13;
	val properties = property_list_to_property_map(init_property_list);&#13;
	&#13;
	val property_definitions = map&lt;name, prop&gt;();&#13;
	&#13;
	for (property in def_property_list) {&#13;
		property_definitions[property.name] = property.prop;&#13;
	}&#13;
	&#13;
	if ("designer_id" in properties) {&#13;
		require(&#13;
			byte_array.from_gtv(properties["designer_id"]) == account_id,&#13;
			"Caller account id is not equal to designer id"&#13;
		);		&#13;
	} else {&#13;
		properties["designer_id"] = account_id.to_gtv();&#13;
	}&#13;
	&#13;
	def_(structure_(structure_name, implements(get_interfaces_by_names(interface_names)),&#13;
		property_definitions,&#13;
		init(properties)&#13;
	));&#13;
}&#13;
&#13;
function new_instance(&#13;
	structure_name: name, &#13;
	properties: list&lt;property&gt;, &#13;
	auth_descriptor_id: byte_array&#13;
): instance {&#13;
	val structure = Structure(structure_name);&#13;
	val designer_id = get_static_property_byte_array(structure, "designer_id");&#13;
	&#13;
	val account = ft3.account @ { designer_id!! };&#13;
	ft3.require_auth(account, auth_descriptor_id, ["T"]);&#13;
	&#13;
	val props = map&lt;name, gtv&gt;();&#13;
	&#13;
	for (property in properties) {&#13;
		props[property.name] = property.value;&#13;
	}&#13;
	&#13;
	props["owner"] = account.to_gtv();&#13;
	&#13;
	return new_(instance_(structure, init(props)));&#13;
}&#13;
&#13;
function __get_child_interfaces(interface_name: name, interface_map: map&lt;name, list&lt;name&gt;&gt;): list&lt;name&gt; {&#13;
	val child_interfaces = list&lt;name&gt;();&#13;
	&#13;
	if (not interface_map.contains(interface_name)) {&#13;
		return list&lt;name&gt;();&#13;
	}&#13;
	&#13;
	for (interface in interface_map[interface_name]) {&#13;
		child_interfaces.add(interface);&#13;
		child_interfaces.add_all(__get_child_interfaces(interface, interface_map));&#13;
	}&#13;
	&#13;
	return child_interfaces;&#13;
}&#13;
&#13;
function get_grouped_interfaces(): map&lt;name, list&lt;map&lt;name, gtv&gt;&gt;&gt; {&#13;
	val ITradeableOriginal = Interface('ITradeableOriginal');&#13;
	&#13;
	val tags = (&#13;
		imt: interface_meta_tag,&#13;
		ei: extended_interface&#13;
	) @* {&#13;
		imt.name == "marketplace_category",&#13;
		imt.interface == ei.extended,&#13;
		ei.base == ITradeableOriginal&#13;
	} (&#13;
		name = imt.value,&#13;
		imt.interface&#13;
	);&#13;
	&#13;
	val category_names = map&lt;name, name&gt;();&#13;
	&#13;
	for ((name, interface) in tags) {&#13;
		category_names[interface.name] = name;&#13;
	}&#13;
	&#13;
	val interfaces = get_interfaces_extending_interface(&#13;
		ITradeableOriginal&#13;
	);&#13;
	&#13;
	val interface_map = map&lt;name, list&lt;name&gt;&gt;();&#13;
	&#13;
	val top_level_interfaces = set&lt;name&gt;();&#13;
	&#13;
	for ((interface, base) in interfaces) {&#13;
		if (base == ITradeableOriginal.name) {&#13;
			top_level_interfaces.add(interface);&#13;
		} else {&#13;
			top_level_interfaces.add(base);&#13;
		}&#13;
	}&#13;
	&#13;
	for ((interface, base) in interfaces) {&#13;
		// 'interface' extends 'base' interface, so it cannot be top level interface&#13;
		if (top_level_interfaces.contains(interface) and base != ITradeableOriginal.name) {&#13;
			top_level_interfaces.remove(interface);&#13;
		}&#13;
		&#13;
		if (interface_map.contains(base)) {&#13;
			interface_map[base].add(interface);&#13;
		} else {&#13;
			interface_map[base] = [interface];&#13;
		}&#13;
	}&#13;
	&#13;
	val grouped_interfaces = map&lt;name, list&lt;map&lt;name, gtv&gt;&gt;&gt;();&#13;
	&#13;
	for (interface in top_level_interfaces) {&#13;
		val name &#13;
			= if (category_names.contains(interface)) &#13;
				category_names[interface] &#13;
			else &#13;
				interface;&#13;
		val child_interfaces = [interface];&#13;
		child_interfaces.add_all(__get_child_interfaces(interface, interface_map));&#13;
		val interface_details = list&lt;map&lt;name, gtv&gt;&gt;();&#13;
		&#13;
		for (child_interface in child_interfaces) {&#13;
			val child_interface_map = map&lt;name, gtv&gt;();&#13;
&#13;
			interface_details.add(interface_definition(Interface(child_interface), id_config(&#13;
				static_key.static,&#13;
				optional_key.non_optional,&#13;
				tags = ["marketplace_label", "marketplace_description"],&#13;
				interface_tags = ["marketplace_name", "marketplace_description"]&#13;
			)));&#13;
		}&#13;
		grouped_interfaces[name] = interface_details;&#13;
	}&#13;
	&#13;
	return grouped_interfaces;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/marketplace/helper.rell">
                                <string>&#13;
&#13;
function map_instances_to_query_result(&#13;
	instances: list&lt;instance&gt;&#13;
): (count: integer, instances: list&lt;map&lt;text, gtv?&gt;&gt;, last_rowid: gtv) {&#13;
	val result = list&lt;map&lt;text, gtv?&gt;&gt;();&#13;
	&#13;
	for (instance in instances) {&#13;
		result.add(map_original_instance(instance));&#13;
	}&#13;
	&#13;
	val last_rowid = &#13;
		if (instances.size() &gt; 0) &#13;
			instances[instances.size()-1].rowid.to_gtv() &#13;
		else &#13;
			(0).to_gtv();&#13;
	&#13;
	return (&#13;
		count = instances.size(),&#13;
		instances = result,&#13;
		last_rowid = last_rowid&#13;
	);&#13;
}&#13;
&#13;
function map_original_instance(instance): map&lt;name, gtv?&gt; {&#13;
	val ITradeableOriginal = Interface("ITradeableOriginal");&#13;
	&#13;
	val mapping_rules = [&#13;
		map_(struct_details(), to_map("_structure")),&#13;
		map_(interfaces([ITradeableOriginal.name]), direct()),&#13;
		map_(interface_props([ITradeableOriginal.name]), to_list("children")),&#13;
		map_(meta_tags(["filter-property"]), to_map("attributes")),&#13;
		map_(tx_history(), to_list("tx_history")),&#13;
		map_(achievements(), to_list("achievements"))&#13;
	];&#13;
	&#13;
	return map_instance(instance, &#13;
		mapping_rules,&#13;
		[&#13;
			interface_type(ITradeableOriginal, mapping_rules)&#13;
		]&#13;
	);&#13;
}&#13;
&#13;
function map_original(structure): map&lt;name, gtv?&gt; {&#13;
	val property_values = map&lt;text, gtv?&gt;();&#13;
	&#13;
	val original_properties = map_structure(structure, [&#13;
		map_(interfaces(["ITradeableOriginal"]), direct()),&#13;
		map_(instance_count(), to_map("_count"))&#13;
	]);&#13;
	&#13;
	property_values.put_all(original_properties);&#13;
	property_values["_name"] = structure.name.to_gtv();&#13;
	&#13;
	return property_values;&#13;
}&#13;
&#13;
function map_original_long(structures: list&lt;structure&gt;): list&lt;map&lt;name, gtv?&gt;&gt; {&#13;
	val result = list&lt;map&lt;text, gtv?&gt;&gt;();&#13;
	for (structure in structures) {&#13;
		val s = map_original(structure);&#13;
		val interfaces = _get_structure_direct_interfaces(structure);&#13;
		val interface = map&lt;name, gtv&gt;();&#13;
		if (interfaces.size() &gt; 0) {&#13;
			//TODO: FIX THIS!!! ONLY FIRST INTERFACE IS USED&#13;
			val i = interfaces[0];&#13;
			val tag = interface_meta_tag @? { i, .name == "marketplace_category"};&#13;
			interface["name"] = i.name.to_gtv();&#13;
			if (tag??) {&#13;
				interface["display_name"] = tag.value.to_gtv();&#13;
			}&#13;
			s["_interface"] = interface.to_gtv();&#13;
		}&#13;
		result.add(s);&#13;
	}&#13;
	return result;&#13;
}&#13;
&#13;
function text_list_to_gtv_list(text_list: list&lt;text&gt;): list&lt;gtv&gt; {&#13;
	val gtv_list = list&lt;gtv&gt;();&#13;
	for (value in text_list) {&#13;
		gtv_list.add(value.to_gtv());&#13;
	}&#13;
	return gtv_list;&#13;
}&#13;
&#13;
function property_list_to_property_map(property_list: list&lt;property&gt;): map&lt;text, gtv&gt; {&#13;
	val properties = map&lt;text, gtv&gt;();&#13;
	&#13;
	for (property in property_list) {&#13;
		properties[property.name] = property.value;&#13;
	}&#13;
	&#13;
	return properties;&#13;
}</string>
                            </entry>
                            <entry key="lib/marketplace/meta_tags.rell">
                                <string>&#13;
function marketplace_description(description: text): tag {&#13;
	return tag("marketplace_description", value(description));&#13;
}&#13;
&#13;
function marketplace_label(label: text): tag {&#13;
	return tag("marketplace_label", value(label));&#13;
}&#13;
&#13;
function category(name): tag {&#13;
	return tag("marketplace_category", value(name));&#13;
}&#13;
&#13;
function marketplace_name(name): tag {&#13;
	return tag("marketplace_name", value(name));&#13;
}</string>
                            </entry>
                            <entry key="lib/marketplace/module.rell">
                                <string>&#13;
import ^.interface.*;&#13;
import ^.structure.*;&#13;
import ^.instance.*;&#13;
import ^.original.*;&#13;
import ^.component_definition.*;&#13;
import ^.component_definition.{&#13;
	property_type&#13;
};</string>
                            </entry>
                            <entry key="lib/marketplace/operations.rell">
                                <string>@mount("marketplace")&#13;
module;&#13;
&#13;
import ^^.marketplace;&#13;
&#13;
operation buy_original_instance(&#13;
	structure_name: name, &#13;
	instance_id: byte_array, &#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	marketplace.buy_original_instance(&#13;
		structure_name, &#13;
		instance_id, &#13;
		account_id, &#13;
		auth_descriptor_id&#13;
	);&#13;
}&#13;
&#13;
operation set_original_instance_trade_info(&#13;
	structure_name: name, &#13;
	instance_id: byte_array, &#13;
	marketplace.trade_info,&#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	marketplace.set_original_instance_trade_info(&#13;
		structure_name, &#13;
		instance_id, &#13;
		trade_info,&#13;
		account_id, &#13;
		auth_descriptor_id&#13;
	);&#13;
}&#13;
&#13;
operation list_original_instance_for_sale(&#13;
	structure_name: name, &#13;
	instance_id: byte_array, &#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	marketplace.set_original_instance_sale_status(&#13;
		structure_name,&#13;
		instance_id,&#13;
		true,&#13;
		account_id,&#13;
		auth_descriptor_id&#13;
	);&#13;
}&#13;
&#13;
operation remove_original_instance_from_sale(&#13;
	structure_name: name, &#13;
	instance_id: byte_array, &#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	marketplace.set_original_instance_sale_status(&#13;
		structure_name,&#13;
		instance_id,&#13;
		false,&#13;
		account_id,&#13;
		auth_descriptor_id&#13;
	);&#13;
}&#13;
&#13;
operation def_original(&#13;
	structure_name: name, &#13;
	interface_names: list&lt;name&gt;,&#13;
	def_property_list: list&lt;marketplace.property_def&gt;,&#13;
	init_property_list: list&lt;marketplace.property&gt;,&#13;
	account_id: byte_array, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	marketplace.def_original(&#13;
		structure_name, &#13;
		interface_names,&#13;
		def_property_list, &#13;
		init_property_list, &#13;
		account_id, &#13;
		auth_descriptor_id&#13;
	);&#13;
}&#13;
&#13;
operation def_structure(&#13;
	structure_name: name, &#13;
	interface_names: list&lt;name&gt;, &#13;
	property_list: list&lt;marketplace.property&gt;,&#13;
	account_id: byte_array,&#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	marketplace.def_structure(&#13;
		structure_name,&#13;
		interface_names,&#13;
		property_list,&#13;
		account_id,&#13;
		auth_descriptor_id&#13;
	);&#13;
}&#13;
&#13;
operation new_instance(&#13;
	structure_name: name, &#13;
	properties: list&lt;marketplace.property&gt;, &#13;
	auth_descriptor_id: byte_array&#13;
) {&#13;
	marketplace.new_instance(&#13;
		structure_name, &#13;
		properties, &#13;
		auth_descriptor_id&#13;
	);&#13;
}</string>
                            </entry>
                            <entry key="lib/marketplace/queries.rell">
                                <string>@mount("marketplace")&#13;
module;&#13;
&#13;
import ^^.marketplace;&#13;
import ^^.instance.*;&#13;
import ^^.original;&#13;
&#13;
query find_originals_by_interface(interface_name: text) {&#13;
	val originals = marketplace.find_originals_by_interface(interface_name, x"");&#13;
	&#13;
	var originals_list = list&lt;map&lt;name, gtv&gt;&gt;();&#13;
	for (original in originals) {&#13;
		val original_map = map&lt;name, gtv&gt;();&#13;
		original_map["name"] = original.name.to_gtv();&#13;
		original_map["display_name"] = get_static_property_text(original, "name")!!.to_gtv();&#13;
	&#13;
		originals_list.add(original_map);&#13;
	}&#13;
	return originals_list;&#13;
}&#13;
&#13;
query find_listed_instances_by_interface(&#13;
	interface_name: text, &#13;
	after_rowid: rowid, &#13;
	page_size: integer&#13;
) {&#13;
	val instances = marketplace.find_listed_instances_by_interface(&#13;
		interface_name, &#13;
		x"", &#13;
		after_rowid, &#13;
		page_size&#13;
	);&#13;
	&#13;
	return marketplace.map_instances_to_query_result(instances);&#13;
}&#13;
&#13;
query find_instances_by_original(original_name: text) {&#13;
	return marketplace.find_instances_by_original(original_name);&#13;
}&#13;
&#13;
query get_categories() {&#13;
	return marketplace.get_categories().to_gtv_pretty();&#13;
}&#13;
&#13;
query find_instance_by_id(structure: name, id: byte_array) {&#13;
	val instance = find_by_id(id);&#13;
	&#13;
	return if (instance??) marketplace.map_original_instance(instance) else null;&#13;
}&#13;
&#13;
query find_original_instances_by_owner_id(&#13;
	owner_id: byte_array, &#13;
	after_rowid: rowid, &#13;
	page_size: integer&#13;
) {&#13;
	var instances = original.find_original_instances_by_owner_id(&#13;
		owner_id, &#13;
		after_rowid, &#13;
		page_size&#13;
	);&#13;
	&#13;
	return marketplace.map_instances_to_query_result(instances);&#13;
}&#13;
&#13;
query find_original_instances_by_owner_id_and_status(&#13;
	owner_id: byte_array, &#13;
	listed_state: boolean, &#13;
	after_rowid: rowid, &#13;
	page_size: integer&#13;
) {&#13;
	var instances = original.find_original_instances_by_owner_id_and_status(&#13;
		owner_id, &#13;
		listed_state, &#13;
		after_rowid, &#13;
		page_size&#13;
	);&#13;
	&#13;
	return marketplace.map_instances_to_query_result(instances);&#13;
}&#13;
&#13;
query find_original_instance_trade_history(instance_id: byte_array) {&#13;
	return original.find_original_trade_events(&#13;
		find_by_id(instance_id)!!&#13;
	);&#13;
}&#13;
&#13;
query find_original_instance_trade_history_page(&#13;
	instance_id: byte_array, &#13;
	before_rowid: rowid, &#13;
	page_size: integer&#13;
) {&#13;
	return original.find_original_trade_events_page(&#13;
		find_by_id(instance_id)!!, &#13;
		before_rowid, &#13;
		page_size&#13;
	);&#13;
}&#13;
&#13;
query get_interface_filters(interface: name) {&#13;
	return marketplace.get_interface_filters(interface, x"");&#13;
}&#13;
&#13;
query search(text, after_rowid: rowid, page_size: integer) {&#13;
	val instances = marketplace.search(text, after_rowid, page_size);&#13;
	&#13;
	return marketplace.map_instances_to_query_result(instances); &#13;
}&#13;
&#13;
query find_originals_by_designer_id(id: byte_array) {&#13;
	val result = marketplace.find_originals_by_designer_id(id);&#13;
	&#13;
	return marketplace.map_original_long(result);&#13;
}&#13;
&#13;
query get_grouped_interfaces() {&#13;
	return marketplace.get_grouped_interfaces();&#13;
}</string>
                            </entry>
                            <entry key="lib/marketplace/search.rell">
                                <string>&#13;
function search(text, after_rowid: rowid, page_size: integer): list&lt;instance&gt; {&#13;
	if (text.size() != 64) return list&lt;instance&gt;();&#13;
	&#13;
	val id = byte_array(text);&#13;
	&#13;
	val ITradeableOriginal = Interface("ITradeableOriginal");&#13;
	&#13;
	val instances = set&lt;instance&gt;();&#13;
	&#13;
	val instance_by_id = (&#13;
		i: instance, &#13;
		si: structure_interface,&#13;
		ip: instance_property,&#13;
		ipvi: instance_property_value_id&#13;
	) @? {&#13;
		i.structure == si.structure,&#13;
		si.interface == ITradeableOriginal,&#13;
		ip.instance == i,		&#13;
		ipvi.value == id,&#13;
		ipvi.instance_property == ip,&#13;
		i.rowid &gt; after_rowid&#13;
	} (&#13;
		i&#13;
	);&#13;
	&#13;
	if (instance_by_id??) {&#13;
		instances.add(instance_by_id);&#13;
	}&#13;
	&#13;
	val instances_by_owner = (&#13;
		i: instance, &#13;
		si: structure_interface,&#13;
		ip: instance_property,&#13;
		ipva: instance_property_value_account&#13;
	) @* {&#13;
		i.structure == si.structure,&#13;
		si.interface == ITradeableOriginal,&#13;
		ip.instance == i,&#13;
		ip.structure_property.name == "owner",&#13;
		ipva.value.id == id,&#13;
		ipva.instance_property == ip,&#13;
		i.rowid &gt; after_rowid&#13;
	} (&#13;
		i,&#13;
		@omit @sort i.rowid&#13;
	) limit page_size;&#13;
	&#13;
	instances.add_all(instances_by_owner);&#13;
	&#13;
	val instances_by_designer = (&#13;
		i: instance, &#13;
		si: structure_interface,&#13;
		sp: static_property,&#13;
		spvb: static_property_value_byte_array&#13;
	) @* {&#13;
		i.structure == si.structure,&#13;
		si.interface == ITradeableOriginal,&#13;
		sp.structure == si.structure,&#13;
		sp.name == "designer_id",&#13;
		spvb.static_property == sp,&#13;
		spvb.value == id,&#13;
		i.rowid &gt; after_rowid&#13;
	} (&#13;
		i,&#13;
		@omit @sort i.rowid&#13;
	) limit page_size;&#13;
	&#13;
	instances.add_all(instances_by_designer);&#13;
	&#13;
	return &#13;
		if (instances.size() &gt; page_size)&#13;
			instances.sorted().sub(0, page_size)&#13;
		else&#13;
			instances.sorted();&#13;
}</string>
                            </entry>
                            <entry key="lib/original/achievement.rell">
                                <string>&#13;
@log &#13;
entity achievement {&#13;
	key name;&#13;
	display_name: name;&#13;
	description: text;&#13;
	image: text;&#13;
}&#13;
&#13;
entity original_achievement_event {&#13;
	key achievement, original_event;&#13;
}&#13;
&#13;
struct achievement_event {&#13;
	name;&#13;
	display_name: name;&#13;
	description: text;&#13;
	image: text;&#13;
	timestamp;&#13;
	block_height: integer;&#13;
}&#13;
&#13;
function add_achievement(&#13;
	name, &#13;
	display_name: name, &#13;
	description: text, &#13;
	image: text&#13;
): achievement {&#13;
	return create achievement(&#13;
		name,&#13;
		display_name,&#13;
		description,&#13;
		image&#13;
	);&#13;
}&#13;
&#13;
function log_achievement_event(instance, achievement_name: name): original_achievement_event {&#13;
	return log_achievement_event_with_description(instance, achievement_name, "");&#13;
}&#13;
&#13;
function log_achievement_event_with_description(&#13;
	instance, &#13;
	achievement_name: name, &#13;
	description: text&#13;
): original_achievement_event {&#13;
	val achievement = achievement @ { .name == achievement_name };&#13;
	&#13;
	val event = create original_event(&#13;
		instance,&#13;
		type = "achievement",&#13;
		level = 1,&#13;
		description&#13;
	);&#13;
	&#13;
	return create original_achievement_event(&#13;
		achievement,&#13;
		event&#13;
	);&#13;
}&#13;
&#13;
function instance_achievements(instance): list&lt;achievement_event&gt; {&#13;
	val events = (event: original_achievement_event, a: achievement, oe: original_event) @* {&#13;
		oe.instance == instance,&#13;
		event.original_event == oe,&#13;
		event.achievement == a&#13;
	} (&#13;
		a.name,&#13;
		a.display_name,&#13;
		description = if (oe.description.size() &gt; 0) oe.description else a.description,&#13;
		a.image,&#13;
//		oe.transaction.block.timestamp,&#13;
		timestamp = 0,&#13;
		@sort_desc oe.transaction.block.block_height&#13;
	);&#13;
	&#13;
	val event_list = list&lt;achievement_event&gt;();&#13;
	for ((name, display_name, description, image, timestamp, block_height) in events) {&#13;
		event_list.add(achievement_event(&#13;
			name,&#13;
			display_name,&#13;
			description,&#13;
			image,&#13;
			timestamp,&#13;
			block_height&#13;
		));&#13;
	}&#13;
	&#13;
	return event_list;&#13;
}</string>
                            </entry>
                            <entry key="lib/original/event.rell">
                                <string>&#13;
@log &#13;
entity original_event {&#13;
	index instance;&#13;
	type: text;&#13;
	level: integer;&#13;
	description: text;&#13;
}&#13;
&#13;
struct event {&#13;
	type: text;&#13;
	level: integer;&#13;
	description: text;&#13;
	timestamp: integer;&#13;
	block_height: integer;&#13;
}&#13;
&#13;
@log &#13;
entity original_trade_event {&#13;
	index instance;&#13;
	seller: ft3.account;&#13;
	buyer: ft3.account;&#13;
	asset_id: byte_array;&#13;
	price: integer;&#13;
}&#13;
&#13;
struct trade_event {&#13;
	seller_id: byte_array;&#13;
	buyer_id: byte_array;&#13;
	asset_id: byte_array;&#13;
	price: integer;&#13;
	timestamp: integer;&#13;
	block_height: integer;&#13;
}&#13;
&#13;
function log_original_event_buy(&#13;
	instance, &#13;
	seller: ft3.account,&#13;
	buyer: ft3.account,  &#13;
	asset_id: byte_array, &#13;
	price: integer&#13;
) {&#13;
	create original_event(&#13;
		instance,&#13;
		type = "buy",&#13;
		level = 0,&#13;
		description = "Original bought from " + seller.id.to_hex() + " by " + buyer.id.to_hex()&#13;
	);&#13;
	&#13;
	create original_trade_event(&#13;
		instance,&#13;
		seller,&#13;
		buyer,&#13;
		asset_id,&#13;
		price&#13;
	);&#13;
}&#13;
&#13;
function log_event(instance, type: text, level: integer, description: text) {&#13;
	create original_event(&#13;
		instance,&#13;
		type,&#13;
		level,&#13;
		description&#13;
	);&#13;
}&#13;
&#13;
function find_original_events_by_type(instance, event_type: text): list&lt;event&gt; {&#13;
	val events = original_event @* { instance, .type == event_type } (&#13;
		.type,&#13;
		.level,&#13;
		.description,&#13;
//		.transaction.block.timestamp,&#13;
		timestamp = 0,&#13;
		@sort_desc .transaction.block.block_height&#13;
	);&#13;
	&#13;
	val event_list = list&lt;event&gt;();&#13;
	&#13;
	for ((type, level, description, block_height, timestamp) in events) {&#13;
		event_list.add(event(type, level, description, block_height, timestamp));&#13;
	}&#13;
	&#13;
	return event_list;&#13;
}&#13;
&#13;
function find_original_events_by_level(instance, event_level: integer): list&lt;event&gt; {&#13;
	val events = original_event @* { instance, .level &lt;= event_level } (&#13;
		.type,&#13;
		.level,&#13;
		.description,&#13;
		timestamp = 0,&#13;
//		timestamp = .transaction.block.timestamp,&#13;
		@sort_desc .transaction.block.block_height&#13;
	);&#13;
	&#13;
	val event_list = list&lt;event&gt;();&#13;
	&#13;
	for ((type, level, description, block_height, timestamp) in events) {&#13;
		event_list.add(event(type, level, description, block_height, timestamp));&#13;
	}&#13;
	&#13;
	return event_list;&#13;
}&#13;
&#13;
function find_original_trade_events(instance): list&lt;trade_event&gt; {&#13;
	val events = original_trade_event @* { instance } (&#13;
		seller_id = .seller.id,&#13;
		buyer_id = .buyer.id,&#13;
		.asset_id,&#13;
		.price,&#13;
		.transaction.block.timestamp,&#13;
		@sort_desc .transaction.block.block_height&#13;
	);&#13;
	&#13;
	val event_list = list&lt;trade_event&gt;();&#13;
	for ((seller_id, buyer_id, asset_id, price, timestamp, block_height) in events) {&#13;
		event_list.add(&#13;
			trade_event(seller_id, buyer_id, asset_id, price, timestamp, block_height)&#13;
		);&#13;
	}&#13;
	&#13;
	return event_list;&#13;
}&#13;
&#13;
function find_original_trade_events_page(&#13;
	instance, &#13;
	before_rowid: rowid, &#13;
	page_size: integer&#13;
): (count: integer, events: list&lt;gtv&gt;, last_rowid: gtv) {&#13;
	val events = (ote: original_trade_event) @* { &#13;
		instance, &#13;
		ote.rowid &lt; before_rowid&#13;
	} (&#13;
		seller_id = .seller.id,&#13;
		buyer_id = .buyer.id,&#13;
		.asset_id,&#13;
		.price,&#13;
		.transaction.block.timestamp,&#13;
		.transaction.block.block_height,&#13;
		@sort_desc .rowid&#13;
	) limit page_size;&#13;
	&#13;
	val event_list = list&lt;gtv&gt;();&#13;
	for ((seller_id, buyer_id, asset_id, price, timestamp, block_height, rowid) in events) {&#13;
		event_list.add(&#13;
			trade_event(seller_id, buyer_id, asset_id, price, timestamp, block_height).to_gtv_pretty()&#13;
		);&#13;
	}&#13;
	&#13;
	val last_rowid =&#13;
		if (events.size() &gt; 0)&#13;
			events[events.size()-1].rowid.to_gtv()&#13;
		else&#13;
			(0).to_gtv();&#13;
	&#13;
	return (&#13;
		count = events.size(),&#13;
		events = event_list,&#13;
		last_rowid = (0).to_gtv()&#13;
	);&#13;
}</string>
                            </entry>
                            <entry key="lib/original/functions.rell">
                                <string>&#13;
function find_original_instances_by_owner_id(&#13;
	owner_id: byte_array, &#13;
	after_rowid: rowid, &#13;
	page_size: integer&#13;
): list&lt;instance&gt; {&#13;
	return (&#13;
		i: instance, &#13;
		ip: instance_property, &#13;
		ipva: instance_property_value_account, &#13;
		si: structure_interface,&#13;
		a: ft3.account&#13;
	) @* {&#13;
		si.interface == Interface("ITradeableOriginal"),&#13;
		i.structure == si.structure,&#13;
		ip.structure_property.name == "owner",&#13;
		ip.instance == i,&#13;
		ipva.instance_property == ip,&#13;
		ipva.value == a,&#13;
		a.id == owner_id,&#13;
		i.rowid &gt; after_rowid&#13;
	} ( @sort i ) limit page_size;&#13;
}&#13;
&#13;
function find_original_instances_by_owner_id_and_status(&#13;
	owner_id: byte_array, &#13;
	listed_state: boolean, &#13;
	after_rowid: rowid, &#13;
	page_size: integer&#13;
): list&lt;instance&gt; {&#13;
	return (&#13;
		i: instance, &#13;
		ip1: instance_property, &#13;
		ip2: instance_property, &#13;
		ipva: instance_property_value_account, &#13;
		ipvb: instance_property_value_boolean,&#13;
		si: structure_interface,&#13;
		a: ft3.account&#13;
	) @* {&#13;
		si.interface == Interface("ITradeableOriginal"),&#13;
		i.structure == si.structure,&#13;
		ip1.structure_property.name == "owner",&#13;
		ip1.instance == i,&#13;
		ip2.structure_property.name == "is_listed",&#13;
		ip2.instance == i,&#13;
		ipva.instance_property == ip1,&#13;
		ipva.value == a,&#13;
		ipvb.instance_property == ip2,&#13;
		ipvb.value == listed_state,&#13;
		a.id == owner_id,&#13;
		i.rowid &gt; after_rowid&#13;
	} ( @sort i ) limit page_size;&#13;
}&#13;
&#13;
</string>
                            </entry>
                            <entry key="lib/original/operations/dev/achievement.rell">
                                <string>&#13;
operation add_achievement(name, display_name: name, description: text, image: text) {&#13;
	original.add_achievement(name, display_name, description, image);&#13;
}&#13;
&#13;
operation log_achievement_event(instance_id: byte_array, achievement_name: name) {&#13;
	val instance = instance.find_by_id(instance_id)!!;&#13;
	original.log_achievement_event(instance, achievement_name);&#13;
}</string>
                            </entry>
                            <entry key="lib/original/operations/dev/module.rell">
                                <string>@mount("dev.original")&#13;
module;&#13;
&#13;
import ^^^.original;&#13;
import ^^^.instance;&#13;
import ft3: rell_modules.ft3.account;</string>
                            </entry>
                            <entry key="lib/original/operations/dev/trade_events.rell">
                                <string>&#13;
operation log_trade_event(&#13;
	instance_id: byte_array, &#13;
	seller_id: byte_array, &#13;
	buyer_id: byte_array, &#13;
	asset_id: byte_array, &#13;
	price: integer&#13;
) {&#13;
	original.log_original_event_buy(&#13;
		original.find_by_id(instance_id)!!,&#13;
		ft3.account @ { buyer_id },&#13;
		ft3.account @ { seller_id },&#13;
		asset_id,&#13;
		price&#13;
	);&#13;
}</string>
                            </entry>
                            <entry key="lib/original/operations/module.rell">
                                <string>@mount('original')&#13;
module;&#13;
</string>
                            </entry>
                            <entry key="lib/original/operations/operations.rell">
                                <string>&#13;
import ^^.component_definition.{&#13;
	property_type&#13;
};&#13;
&#13;
import ^^.instance.{&#13;
	property,&#13;
	set_property,&#13;
	find_by_id,&#13;
	set_property_account,&#13;
	is_text_or_byte_array,&#13;
	_instance_property,&#13;
	_set_property_instance&#13;
};&#13;
&#13;
import ^^.structure.{&#13;
	Structure&#13;
};&#13;
&#13;
import ft3: rell_modules.ft3.account;&#13;
&#13;
operation set_instance_properties(id: byte_array, properties: list&lt;property&gt;) {&#13;
	_set_instance_properties(id, properties);&#13;
}&#13;
&#13;
function _set_instance_properties(id: byte_array, properties: list&lt;property&gt;) {&#13;
	val instance = find_by_id(id)!!;&#13;
	&#13;
	for (property in properties) {&#13;
		val instance_property = _instance_property(instance, property.name);&#13;
		&#13;
		// TODO: improve the code, because set_property internally fetches intance_property&#13;
		when(instance_property.structure_property.type) {&#13;
			property_type.interface,&#13;
			property_type.structure -&gt; {&#13;
				if(is_text_or_byte_array(property.value)) {&#13;
					val instance_id = byte_array.from_gtv(property.value);&#13;
					val i = find_by_id(instance_id)!!;&#13;
					_set_property_instance(instance_property, i); &#13;
				}&#13;
			}&#13;
			property_type.account -&gt; {&#13;
				val account_id = byte_array.from_gtv(property.value);&#13;
				val account = ft3.account @ { account_id };&#13;
				set_property_account(instance, property.name, account);&#13;
			}&#13;
			else -&gt; {&#13;
				set_property(instance, property.name, property.value);&#13;
			}&#13;
		}&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/original/original.rell">
                                <string>import ^.interface.*;&#13;
import ^.instance.*;&#13;
&#13;
function initialize_originals() {&#13;
	val OriginalImage = def_(structure_("OriginalImage", [&#13;
		"data": prop(propT(txt())),&#13;
		"type": prop(propT(txt()))&#13;
	]));&#13;
	&#13;
	val ITradeable = defI(interface_("ITradeable", [&#13;
		"price": prop(&#13;
			optional(),&#13;
			propI(int())&#13;
		),&#13;
		"asset_id": prop(&#13;
			optional(),&#13;
			propB(bytes())&#13;
		),&#13;
		"image": prop(&#13;
			static(),&#13;
			readonly(),&#13;
			propS(strct(OriginalImage))&#13;
		),&#13;
		"is_listed": prop(propBool(bool(&#13;
			value = false&#13;
		)))&#13;
	]));&#13;
	&#13;
	val IOriginal = defI(interface_("IOriginal",&#13;
		[&#13;
			"id": prop(propID(id())),&#13;
			"index": prop(propIndx(indx())),&#13;
			"name": prop(&#13;
				static(),&#13;
				readonly(),&#13;
				propT(txt())&#13;
			),&#13;
			"owner": prop(&#13;
				optional(),&#13;
				propA(account())&#13;
			),&#13;
			"designer_id": prop(&#13;
				static(),&#13;
				readonly(),&#13;
				propB(bytes())&#13;
			),&#13;
			"designer_name": prop(&#13;
				static(),&#13;
				readonly(),&#13;
				propT(txt())&#13;
			),&#13;
			"description": prop(&#13;
				static(),&#13;
				propT(txt())&#13;
			)&#13;
		]&#13;
	));&#13;
	&#13;
	val ITradeableOriginal = defI(interface_("ITradeableOriginal", extends([IOriginal, ITradeable])));&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/boolean.rell">
                                <string>&#13;
&#13;
/* &#13;
 * instance properties&#13;
 */&#13;
&#13;
function _create_structure_property_boolean(structure, name, prop): structure_property {&#13;
	val bool_props = bool.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val value = bool_props.value;&#13;
	&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.boolean,&#13;
		value = if (value??) value.to_gtv().to_bytes() else x""&#13;
	);&#13;
	&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
/* static properties */&#13;
&#13;
entity static_property_value_boolean {&#13;
	key static_property;&#13;
	mutable value: boolean;&#13;
}&#13;
&#13;
function set_static_property_boolean(structure, property_name: name, value: boolean) {&#13;
	_set_static_property_boolean(_static_property(structure, property_name), value);&#13;
}&#13;
&#13;
function _set_static_property_boolean(static_property, value: boolean) {&#13;
	val property = static_property_value_boolean @? { static_property };&#13;
	&#13;
	if (property??) {&#13;
		property.value = value;&#13;
	} else {&#13;
		create static_property_value_boolean(&#13;
			static_property,&#13;
			value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_static_property_boolean(structure, property_name: name): boolean? {&#13;
	return _get_static_property_boolean(_static_property(structure, property_name));&#13;
}&#13;
&#13;
function _get_static_property_boolean(static_property): boolean? {&#13;
	require(static_property.type == property_type.boolean);&#13;
	return static_property_value_boolean @? { static_property }?.value;&#13;
}&#13;
&#13;
function unset_property_s_bool(static_property) {&#13;
	delete static_property_value_boolean @ { static_property };&#13;
}&#13;
&#13;
function create_static_structure_property_boolean(&#13;
	structure, &#13;
	name, &#13;
	prop, &#13;
	init_value: gtv?&#13;
): static_property {&#13;
	val property = create static_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.boolean&#13;
	);&#13;
	&#13;
	_create_static_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	val bool_def = bool.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val value = bool_def.value;&#13;
	val init_value_bool = if (init_value??) boolean.from_gtv(init_value) else null;&#13;
	&#13;
	require(&#13;
		value != null or init_value_bool != null or prop.optional.value == true,&#13;
		"Non-optional property '" + name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly.value == false&#13;
			or&#13;
		((value == null or init_value_bool == null) and prop.readonly.value == true),&#13;
		"Read-only property '" + name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_bool ?: value;&#13;
	&#13;
	if (v??) {&#13;
		create static_property_value_boolean(&#13;
			property,&#13;
			v&#13;
		);&#13;
	}&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/byte_array.rell">
                                <string>entity static_property_value_byte_array {&#13;
	static_property;&#13;
	mutable value: byte_array;&#13;
}&#13;
&#13;
function set_static_property_byte_array(structure, property_name: name, value: byte_array) {&#13;
	_set_static_property_byte_array(_static_property(structure, property_name), value);&#13;
}&#13;
&#13;
function _set_static_property_byte_array(static_property, value: byte_array) {&#13;
	val property_value = static_property_value_byte_array @? { static_property };&#13;
&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create static_property_value_byte_array(&#13;
			static_property,&#13;
			value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_static_property_byte_array(structure, name): byte_array? {&#13;
	return _get_static_property_byte_array(_static_property(structure, name));&#13;
}&#13;
&#13;
function _get_static_property_byte_array(static_property): byte_array? {&#13;
	return static_property_value_byte_array @? {&#13;
		static_property&#13;
	}?.value;&#13;
}&#13;
&#13;
function _create_structure_property_byte_array(structure, name, prop): structure_property {&#13;
	val byte_array_props = bytes.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val v = if (byte_array_props.value != null) byte_array_props.value!! else x"";&#13;
	&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.byte_array,&#13;
		value = v&#13;
	);&#13;
		&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
function create_static_property_byte_array(&#13;
	structure, &#13;
	name, &#13;
	prop, &#13;
	init_value: gtv?&#13;
): static_property {&#13;
	val property = create static_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.byte_array&#13;
	);&#13;
	&#13;
	_create_static_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	val bytes_def = bytes.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val value = bytes_def.value;&#13;
	val init_value_bytes = if (init_value??) byte_array.from_gtv(init_value) else null;&#13;
	&#13;
	require(&#13;
		value != null or init_value_bytes != null or prop.optional.value == true,&#13;
		"Non-optional byte_array property '" + name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly.value == false&#13;
			or&#13;
		((value == null or init_value_bytes == null) and prop.readonly.value == true),&#13;
		"Read-only byte_array property '" + name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_bytes ?: value;&#13;
	&#13;
	if (v??) {&#13;
		create static_property_value_byte_array(&#13;
			property,&#13;
			v&#13;
		);&#13;
	}&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/definition.rell">
                                <string>&#13;
struct sd_config {&#13;
	static: static_key = static_key.all;&#13;
	optional: optional_key = optional_key.all;&#13;
	meta: boolean = false;&#13;
	tags: list&lt;name&gt; = list&lt;name&gt;();&#13;
}&#13;
&#13;
function structure_definition(structure, sd_config): map&lt;name, gtv&gt; {&#13;
	val structure_definition_map = map&lt;name, gtv&gt;();&#13;
	structure_definition_map["name"] = structure.name.to_gtv();&#13;
	structure_definition_map["properties"] = __structure.structure_property_definitions(structure, sd_config).to_gtv();&#13;
	return structure_definition_map;&#13;
}&#13;
&#13;
namespace __structure {&#13;
	function structure_property_definitions(structure, sd_config): map&lt;name, gtv&gt; {&#13;
		val properties_map = map&lt;name, gtv&gt;();&#13;
		&#13;
		if (sd_config.static != static_key.non_static) {&#13;
			properties_map.put_all(static_property_definitions(structure, sd_config));&#13;
		}&#13;
		&#13;
		if (sd_config.static != static_key.static) {&#13;
			properties_map.put_all(property_definitions(structure, sd_config));&#13;
		}&#13;
		&#13;
		return properties_map;&#13;
	}&#13;
	&#13;
	function property_definitions(structure, sd_config): map&lt;name, gtv&gt; {	&#13;
		val structure_properties = structure_property @* { structure };&#13;
		val properties_map = map&lt;name, gtv&gt;();&#13;
		for (structure_property in structure_properties) {&#13;
			properties_map[structure_property.name] &#13;
				= property_definition(structure_property, sd_config).to_gtv();&#13;
		}&#13;
		return properties_map;&#13;
	}&#13;
	&#13;
	function property_definition(structure_property, sd_config): map&lt;name, gtv&gt; {&#13;
		val property_definition_map = map&lt;name, gtv&gt;();&#13;
		&#13;
		property_definition_map["type"] = property_type(structure_property).to_gtv();&#13;
		&#13;
		if (sd_config.static == static_key.all) {&#13;
			property_definition_map["static"] = (false).to_gtv();&#13;
		}&#13;
		&#13;
		if (sd_config.meta or sd_config.tags.size() &gt; 0) {&#13;
			property_definition_map["meta"] &#13;
				= property_meta(structure_property, sd_config.tags).to_gtv();&#13;
		}&#13;
		&#13;
		if (sd_config.optional == optional_key.all) {&#13;
			property_definition_map["optional"] = structure_property.optional.to_gtv();&#13;
		}&#13;
		&#13;
		return property_definition_map;&#13;
	}&#13;
	&#13;
	function property_type(structure_property): name {&#13;
		when (structure_property.type) {&#13;
			property_type.interface -&gt;&#13;
				return structure_property_interface @ { &#13;
					structure_property&#13;
				} ( &#13;
					.interface.name&#13;
				);&#13;
			property_type.structure -&gt;&#13;
				return structure_property_structure @ {&#13;
					structure_property&#13;
				} (&#13;
					.structure.name				&#13;
				);&#13;
			else -&gt; {&#13;
				val type = structure_property.type;&#13;
				return type.name;&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	function property_meta(structure_property, tags: list&lt;name&gt;): map&lt;name, gtv&gt; {&#13;
		val property_meta_map = map&lt;name, gtv&gt;();&#13;
		&#13;
		if (tags.size() == 0) {&#13;
			val meta_tags = structure_property_meta_tag @* { structure_property };&#13;
			for (tag in meta_tags) {&#13;
				property_meta_map[tag.name] = tag.value.to_gtv();&#13;
			}&#13;
		} else {&#13;
			for (tag in tags) {&#13;
				val meta_tag = structure_property_meta_tag @? { structure_property, .name == tag };&#13;
				&#13;
				if (meta_tag??) {&#13;
					property_meta_map[meta_tag.name] = meta_tag.value.to_gtv();&#13;
				}&#13;
			}&#13;
		}&#13;
		&#13;
		return property_meta_map;&#13;
	}&#13;
	&#13;
	function static_property_definitions(structure, sd_config): map&lt;name, gtv&gt; {&#13;
		val properties = static_property @* { structure };&#13;
		val properties_map = map&lt;name, gtv&gt;();&#13;
		for (property in properties) {&#13;
			properties_map[property.name] = static_property_definition(property, sd_config).to_gtv();&#13;
		}&#13;
		return properties_map;&#13;
	}&#13;
	&#13;
	function static_property_definition(static_property, sd_config): map&lt;name, gtv&gt; {&#13;
		val property_definition_map = map&lt;name, gtv&gt;();&#13;
		&#13;
		property_definition_map["type"] = static_property_type(static_property).to_gtv();&#13;
		&#13;
		if (sd_config.static == static_key.all) {&#13;
			property_definition_map["static"] = (true).to_gtv();&#13;
		}&#13;
		&#13;
		if (sd_config.meta or sd_config.tags.size() &gt; 0) {&#13;
			property_definition_map["meta"]&#13;
				= static_property_meta(static_property, sd_config.tags).to_gtv();&#13;
		}&#13;
		&#13;
		if (sd_config.optional == optional_key.all) {&#13;
			property_definition_map["optional"] = static_property.optional.to_gtv();&#13;
		}&#13;
		&#13;
		return property_definition_map;&#13;
	}&#13;
	&#13;
	function static_property_type(static_property): text {&#13;
			when (static_property.type) {&#13;
			property_type.interface -&gt;&#13;
				return static_property_interface @ { &#13;
					static_property&#13;
				} ( &#13;
					.interface.name&#13;
				);&#13;
			property_type.structure -&gt;&#13;
				return static_property_structure @ {&#13;
					static_property&#13;
				} (&#13;
					.structure.name				&#13;
				);&#13;
			else -&gt; {&#13;
				val type = static_property.type;&#13;
				return type.name;&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	function static_property_meta(static_property, tags: list&lt;name&gt;): map&lt;name, gtv&gt; {&#13;
		val property_meta_map = map&lt;name, gtv&gt;();&#13;
		&#13;
		if (tags.size() == 0) {&#13;
			val meta_tags = static_property_meta_tag @* { static_property };&#13;
			for (tag in meta_tags) {&#13;
				property_meta_map[tag.name] = tag.value.to_gtv();&#13;
			}&#13;
		} else {&#13;
			for (tag in tags) {&#13;
				val meta_tag = static_property_meta_tag @? { static_property, .name == tag };&#13;
				&#13;
				if (meta_tag??) {&#13;
					property_meta_map[meta_tag.name] = meta_tag.value.to_gtv();				&#13;
				}&#13;
			}&#13;
		}&#13;
		&#13;
		return property_meta_map;&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/enum.rell">
                                <string>&#13;
entity structure_property_enum {&#13;
	key structure_property;&#13;
	_enum;&#13;
}&#13;
&#13;
function _create_property_enum(structure, name, prop): structure_property {&#13;
	val enum_prop = enm.from_gtv(prop.prop_type_struct.type_gtv);&#13;
		&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type._enum,&#13;
		value = x""&#13;
	);&#13;
	&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	create structure_property_enum(property, enum_prop._enum);&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
function set_static_property_enum(structure, property_name: name, value: enum_value) {&#13;
	val static_property = _static_property(structure, property_name);&#13;
	_set_static_property_enum(static_property, value);&#13;
}&#13;
&#13;
function _set_static_property_enum(static_property, value: enum_value) {&#13;
	val property_value = static_property_value_enum @? { static_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create static_property_value_enum(&#13;
			static_property,&#13;
			value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_static_property_enum(structure, property_name: name): enum_value? {&#13;
	return _get_static_property_enum(&#13;
		_static_property(structure, property_name)&#13;
	);&#13;
}&#13;
&#13;
function _get_static_property_enum(static_property): enum_value? {&#13;
	return static_property_value_enum @? { &#13;
		static_property&#13;
	}.value;&#13;
}&#13;
&#13;
function _get_static_property_enum_serialized(static_property): gtv? {&#13;
	return _get_static_property_enum(static_property)?.value?.to_gtv();&#13;
}&#13;
&#13;
entity static_property_value_enum {&#13;
	key static_property;&#13;
	mutable value: enum_value;&#13;
}&#13;
&#13;
function _create_static_property_enum(&#13;
	structure, &#13;
	name, &#13;
	prop, &#13;
	init_value: gtv?&#13;
): static_property {&#13;
	val property = create static_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type._enum&#13;
	);&#13;
	&#13;
	_create_static_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	val init_value_enum = if (init_value??) enum_value.from_gtv(init_value) else null;&#13;
	&#13;
	require(&#13;
		init_value_enum != null or prop.optional.value == true,&#13;
		"Non-optional enum property '" + name + "' is not initialized"&#13;
	); &#13;
	&#13;
	if (init_value_enum??) {&#13;
		create static_property_value_enum(&#13;
			property,&#13;
			init_value_enum&#13;
		);&#13;
	}&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/ft3_account.rell">
                                <string>/* instance properties */&#13;
&#13;
function _create_structure_property_account(structure, name, prop): structure_property {&#13;
	val account_props = account.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.account,&#13;
		value = x""&#13;
	);&#13;
	&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
entity static_property_value_account {&#13;
	key static_property;&#13;
	mutable value: ft3.account;&#13;
}&#13;
&#13;
function set_static_property_account(structure, property_name: name, value: ft3.account) {&#13;
	_set_static_property_account(_static_property(structure, property_name), value);&#13;
}&#13;
&#13;
function _set_static_property_account(static_property, value: ft3.account) {&#13;
	require(&#13;
		static_property.readonly == false,&#13;
		"Cannot update read-only property '" + static_property.name + "'"&#13;
	);&#13;
	&#13;
	val property_value = static_property_value_account @? { static_property };&#13;
	&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create static_property_value_account(&#13;
			static_property,&#13;
			value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_static_property_account(structure, property_name: name): ft3.account? {&#13;
	return _get_static_property_account(_static_property(structure, property_name));&#13;
}&#13;
&#13;
function _get_static_property_account(static_property): ft3.account? {&#13;
	return static_property_value_account @? { static_property }.value;&#13;
}&#13;
&#13;
function _get_static_property_account_serialized(static_property): gtv? {&#13;
	return _get_static_property_account(static_property)?.id?.to_gtv();&#13;
}&#13;
&#13;
function _create_static_property_account(&#13;
	structure, &#13;
	name, &#13;
	prop, &#13;
	init_value: gtv?&#13;
): static_property {&#13;
	val property = create static_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.account&#13;
	);&#13;
	&#13;
	_create_static_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	val value = if (init_value??) ft3.account.from_gtv(init_value) else null;&#13;
	&#13;
	require(&#13;
		value != null or prop.optional.value == true,&#13;
		"Non-optional property '" + name + "' is not initialized"&#13;
	);&#13;
	&#13;
	if (value??) {&#13;
		create static_property_value_account(&#13;
			property,&#13;
			value&#13;
		);&#13;
	}&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/functions.rell">
                                <string>struct property {&#13;
	name;&#13;
	value: gtv;&#13;
}&#13;
&#13;
function structure_implements_interface(structure, interface): boolean {&#13;
	return structure_interface @? { structure, interface } != null;&#13;
}&#13;
&#13;
function _get_static_properties_of_interface(&#13;
	structure, &#13;
	interface&#13;
): list&lt;static_property&gt; {&#13;
	&#13;
	// query returns all static properties defined by interface&#13;
	// and intererface's base interfaces &#13;
	val static_properties = (&#13;
		si: structure_interface,&#13;
		ei: extended_interface,&#13;
		sp: static_property,&#13;
		infp: interface_property&#13;
	) @* {&#13;
		si.structure == structure,&#13;
		si.interface == interface&#13;
			or&#13;
		(ei.extended == interface and si.interface == ei.base),&#13;
		infp.interface == si.interface,&#13;
		sp.structure == structure,&#13;
		sp.name == infp.name&#13;
	} ( sp );&#13;
&#13;
	return set&lt;static_property&gt;(static_properties).sorted();&#13;
}&#13;
&#13;
function _get_static_properties_of_interfaces(&#13;
	structure, &#13;
	interfaces: list&lt;interface&gt;&#13;
): list&lt;static_property&gt; {&#13;
	val static_properties = set&lt;static_property&gt;();&#13;
	for (interface in interfaces) {&#13;
		static_properties.add_all(&#13;
			_get_static_properties_of_interface(structure, interface)&#13;
		);&#13;
	}&#13;
	return static_properties.sorted();&#13;
}&#13;
&#13;
function _get_structure_direct_interfaces(structure): list&lt;interface&gt; {&#13;
	return structure_interface @* { structure, .direct == true } ( .interface );&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/id.rell">
                                <string>&#13;
function _create_structure_property_id(structure, name, prop): structure_property {&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = true,&#13;
		optional = false,&#13;
		type = property_type.id,&#13;
		value = x""&#13;
	);&#13;
	&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/index.rell">
                                <string>&#13;
entity structure_property_index_max_count {&#13;
	key structure_property;&#13;
	value: integer;&#13;
}&#13;
&#13;
function _create_structure_property_index(structure, name, prop): structure_property {&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = true,&#13;
		optional = false,&#13;
		type = property_type.indx,&#13;
		value = x""&#13;
	);&#13;
	&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	val max_count = indx.from_gtv(prop.prop_type_struct.type_gtv).max_count;&#13;
	&#13;
	if (max_count??) {&#13;
		create structure_property_index_max_count(&#13;
			property,&#13;
			max_count&#13;
		);&#13;
	}&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/instance.rell">
                                <string>entity static_property_value_instance {&#13;
	key static_property;&#13;
	mutable value: instance;&#13;
}&#13;
&#13;
function set_static_property_instance(structure, property_name: name, value: instance) {&#13;
	_set_static_property_instance(_static_property(structure, property_name), value);&#13;
}&#13;
&#13;
function _set_static_property_instance(static_property, value: instance) {	&#13;
	_require_static_property_not_readonly(static_property);&#13;
	_require_instance_is_of_valid_type(static_property, value);&#13;
	&#13;
	val instance_value = &#13;
		if (value.structure.is_entity)&#13;
			value&#13;
		else &#13;
			deep_copy(value);&#13;
	&#13;
	val property_value = static_property_value_instance @? { static_property };&#13;
	&#13;
	if (property_value??) {&#13;
		val old_value = property_value.value;&#13;
		&#13;
		property_value.value = instance_value;&#13;
		&#13;
		if (not old_value.structure.is_entity) {&#13;
			_delete_instance(old_value);&#13;
		}	&#13;
	} else {&#13;
		create static_property_value_instance(&#13;
			static_property,&#13;
			value = instance_value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_static_property_instance(structure, property_name: name): instance? {&#13;
	return _get_static_property_instance(&#13;
		_static_property(structure, property_name)&#13;
	);&#13;
}&#13;
&#13;
function _get_static_property_instance(static_property): instance? {&#13;
	_require_static_property_structure_or_interface(static_property);&#13;
	&#13;
	return static_property_value_instance @? { static_property }.value;&#13;
}&#13;
&#13;
function _get_static_property_instance_serialized(static_property): gtv? {&#13;
	val instance = _get_static_property_instance(static_property);&#13;
	&#13;
	return if (instance??) &#13;
			map_instance(instance, &#13;
				[&#13;
					map_(all_properties(), direct())&#13;
				],&#13;
				all()&#13;
			).to_gtv()&#13;
		else&#13;
			null;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/integer.rell">
                                <string>/* instance properties */&#13;
&#13;
function _create_structure_property_integer(structure, name, prop): structure_property {&#13;
	val int_props = int.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val v = if (int_props.value != null) int_props.value!!.to_gtv().to_bytes() else x"";&#13;
	&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.integer,&#13;
		value = v&#13;
	);&#13;
&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
/* static properties */&#13;
&#13;
entity static_property_value_integer {&#13;
	key static_property;&#13;
	mutable value: integer;&#13;
}&#13;
&#13;
function set_static_property_integer(structure, property_name: name, value: integer) {&#13;
	&#13;
}&#13;
&#13;
function _set_static_property_integer(static_property, value: integer) {&#13;
	val property = static_property_value_integer @? { static_property };&#13;
	&#13;
	if (property??) {&#13;
		property.value = value;&#13;
	} else {&#13;
		create static_property_value_integer(&#13;
			static_property,&#13;
			value = value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
&#13;
function get_static_property_integer(structure, name): integer? {&#13;
	return _get_static_property_integer(_static_property(structure, name));&#13;
}&#13;
&#13;
function _get_static_property_integer(static_property): integer?{&#13;
	require(static_property.type == property_type.integer);&#13;
	return static_property_value_integer @? { &#13;
		static_property&#13;
	}.value;&#13;
}&#13;
&#13;
function unset_property_s_integer(static_property) {&#13;
	delete static_property_value_integer @ { static_property };&#13;
}&#13;
&#13;
function create_static_property_integer(&#13;
	structure, &#13;
	name, &#13;
	prop, &#13;
	init_value: gtv?&#13;
): static_property {&#13;
	val property = create static_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.integer&#13;
	);&#13;
	&#13;
	_create_static_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	val int_def = int.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val value = int_def.value;&#13;
	val init_value_int = if (init_value??) integer.from_gtv(init_value) else null;&#13;
	&#13;
	require(&#13;
		value != null or init_value_int != null or prop.optional.value == true,&#13;
		"Non-optional property '" + name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly.value == false&#13;
			or&#13;
		((value == null or init_value_int == null) and prop.readonly.value == true),&#13;
		"Readonly property '" + name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_int ?: value;&#13;
	&#13;
	if (v??) {&#13;
		create static_property_value_integer(&#13;
			property,&#13;
			v&#13;
		);&#13;
	}&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/interface.rell">
                                <string>&#13;
entity structure_property_interface {&#13;
	key structure_property;&#13;
	interface;&#13;
}&#13;
&#13;
entity static_property_interface {&#13;
	key static_property;&#13;
	interface;&#13;
}&#13;
&#13;
function _create_structure_property_interface(structure, name, prop): structure_property {	&#13;
	val interface_prop = inf.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.interface,&#13;
		value = x""&#13;
	);&#13;
	&#13;
	create structure_property_interface(&#13;
		property,&#13;
		interface_prop.interface&#13;
	);&#13;
&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/structure/main.rell">
                                <string>import ^.interface.*;&#13;
import ^.instance.*;&#13;
import ^.component_definition.*;&#13;
import ^.component_definition.{&#13;
	property_type&#13;
};&#13;
&#13;
entity structure_interface {&#13;
	index structure;&#13;
	key structure, interface;&#13;
	direct: boolean;&#13;
}&#13;
&#13;
entity structure {&#13;
	key name;&#13;
	description: text;&#13;
	id_property_name: name = "";&#13;
	is_entity: boolean = false;&#13;
}&#13;
&#13;
entity static_property {&#13;
	index structure;&#13;
	key name, structure;&#13;
	name;&#13;
	type: property_type;&#13;
	readonly: boolean;&#13;
	optional: boolean;&#13;
}&#13;
&#13;
entity static_property_meta_tag {&#13;
	index static_property;&#13;
	key static_property, name;&#13;
	value: text;&#13;
}&#13;
&#13;
entity structure_property {&#13;
	index structure;&#13;
	key name, structure;&#13;
	name;&#13;
	type: property_type;&#13;
	readonly: boolean;&#13;
	optional: boolean;&#13;
	value: byte_array;&#13;
	// add extra for type specific configuration?&#13;
}&#13;
&#13;
entity structure_property_meta_tag {&#13;
	index structure_property;&#13;
	key structure_property, name;&#13;
	value: text;&#13;
}&#13;
&#13;
struct init {&#13;
	properties: map&lt;text, gtv&gt;;&#13;
}&#13;
&#13;
struct structure_ {&#13;
	name;&#13;
	implements = implements(list&lt;interface&gt;());&#13;
	properties: map&lt;text, prop&gt; = map&lt;text, prop&gt;();&#13;
	description = description("");&#13;
	init = init(map&lt;text, gtv&gt;());&#13;
}&#13;
&#13;
function def_(structure_): structure {&#13;
	val direct_interfaces = set&lt;interface&gt;();&#13;
	val indirect_interfaces = set&lt;interface&gt;();&#13;
	&#13;
	val implemented_interfaces = set&lt;interface&gt;();&#13;
	for (interface in structure_.implements.interfaces) {&#13;
		if (not implemented_interfaces.contains(interface)) {&#13;
			implemented_interfaces.add(interface);&#13;
			direct_interfaces.add(interface);&#13;
		}&#13;
	}&#13;
	&#13;
	for (interface in structure_.implements.interfaces) {&#13;
		for (intf in interface_extended_interfaces(interface)) {&#13;
			if (not implemented_interfaces.contains(intf)) {&#13;
				implemented_interfaces.add(intf);&#13;
				indirect_interfaces.add(intf);&#13;
			}				&#13;
		}&#13;
	}	&#13;
	&#13;
	val props = map&lt;name, prop&gt;();&#13;
	&#13;
	for (interface in implemented_interfaces) {&#13;
		for (property in interface_property @* { interface }) {&#13;
			val prop = prop.from_bytes(property.encoded_prop);&#13;
			&#13;
			require(&#13;
				not props.contains(property.name) &#13;
					or &#13;
				props[property.name].prop_type_struct.type == prop.prop_type_struct.type,&#13;
				"Cannot implement two properties of same name but different type"&#13;
			);&#13;
			&#13;
			props[property.name] = prop;		&#13;
		}&#13;
	}&#13;
	&#13;
	&#13;
	for ((name, prop) in structure_.properties) {&#13;
		// TODO: check if property of the same name but different &#13;
		// type is defined in one of the implemented interfaces&#13;
		// TODO: check if strucutre's property definition is trying to override&#13;
		// property defined in interface, e.g. interface has instance max count set to 100&#13;
		// but sturucte's property of index type is defined without max count &#13;
&#13;
		props[name] = prop;&#13;
	}&#13;
	&#13;
&#13;
	val id_property_name = _get_id_property(props);	&#13;
	// TODO: make sure structure doesn't have more than 1 property of index type &#13;
	&#13;
	val structure = create structure(&#13;
		name = structure_.name,&#13;
		description = structure_.description.value,&#13;
		id_property_name = id_property_name ?: "",&#13;
		is_entity = id_property_name??&#13;
	);&#13;
	&#13;
	for (interface in direct_interfaces) {&#13;
		create structure_interface (&#13;
			structure,&#13;
			interface,&#13;
			direct = true&#13;
		);&#13;
	}&#13;
	&#13;
	for (interface in indirect_interfaces) {&#13;
		create structure_interface (&#13;
			structure,&#13;
			interface,&#13;
			direct = false&#13;
		);&#13;
	}&#13;
	&#13;
	&#13;
	for ((name, prop) in props) {&#13;
		val value = &#13;
			if (name in structure_.init.properties) &#13;
				structure_.init.properties[name] &#13;
			else &#13;
				null;&#13;
		&#13;
		&#13;
		if (prop.static.value == true) {&#13;
			handle_static_property(structure, name, prop, value);&#13;
		} else {&#13;
			handle_property(structure, name, prop, value);&#13;
		}&#13;
	}&#13;
	&#13;
	return structure;&#13;
}&#13;
&#13;
function Structure(name): structure {&#13;
	return structure @ { .name == name };&#13;
}&#13;
&#13;
function structure_base_interfaces(structure): list&lt;interface&gt; {&#13;
	return structure_interface @* {&#13;
		structure,&#13;
		.direct == true&#13;
	} ( .interface );&#13;
}&#13;
&#13;
function structure_implemented_interfaces(structure): list&lt;interface&gt; {&#13;
	return structure_interface @* {&#13;
		structure&#13;
	} ( .interface );&#13;
}&#13;
&#13;
function structures_implementing_interface(interface): list&lt;structure&gt; {&#13;
	return structure_interface @* {&#13;
		interface&#13;
	} ( .structure );&#13;
}&#13;
&#13;
function handle_static_property(structure, name, prop, value: gtv?) {&#13;
	when (prop.prop_type_struct.type) {&#13;
		property_type.integer -&gt;&#13;
			create_static_property_integer(structure, name, prop, value);&#13;
		property_type.text -&gt; &#13;
			create_static_property_text(structure, name, prop, value);&#13;
		property_type.byte_array -&gt;&#13;
			create_static_property_byte_array(structure, name, prop, value);&#13;
		property_type.structure -&gt;&#13;
			_create_static_property_structure(structure, name, prop, value);&#13;
		property_type.boolean -&gt;&#13;
			create_static_structure_property_boolean(structure, name, prop, value);&#13;
		property_type._enum -&gt;&#13;
			_create_static_property_enum(structure, name, prop, value);&#13;
		property_type.account -&gt;&#13;
			_create_static_property_account(structure, name, prop, value);&#13;
	}&#13;
}&#13;
&#13;
function handle_property(structure, name, prop, init_value: gtv?) {&#13;
	require(&#13;
		init_value == null, &#13;
		"Instance properties can be initialized only during structure instantiation"&#13;
	);&#13;
	&#13;
	when (prop.prop_type_struct.type) {&#13;
		property_type.integer -&gt; &#13;
			_create_structure_property_integer(structure, name, prop);&#13;
		property_type.text -&gt; &#13;
			_create_structure_property_text(structure, name, prop);&#13;
		property_type.indx -&gt; &#13;
			_create_structure_property_index(structure, name, prop);&#13;
		property_type.byte_array -&gt; &#13;
			_create_structure_property_byte_array(structure, name, prop);&#13;
		property_type.interface -&gt; &#13;
			_create_structure_property_interface(structure, name, prop);&#13;
		property_type.structure -&gt; &#13;
			_create_structure_property_structure(structure, name, prop);&#13;
		property_type.account -&gt; &#13;
			_create_structure_property_account(structure, name, prop);&#13;
		property_type.boolean -&gt; &#13;
			_create_structure_property_boolean(structure, name, prop);&#13;
		property_type.id -&gt;&#13;
			_create_structure_property_id(structure, name, prop);&#13;
		property_type._enum -&gt; &#13;
			_create_property_enum(structure, name, prop);&#13;
	}&#13;
}&#13;
&#13;
function set_static_property(structure, name, value: gtv) {&#13;
	val property = static_property @ { .name == name, structure };&#13;
	&#13;
	require(property.readonly == false, "Cannot set read-only static property '" + name + "'");&#13;
	&#13;
	when(property.type) {&#13;
		property_type.integer -&gt; &#13;
			_set_static_property_integer(property, integer.from_gtv(value));&#13;
		property_type.text -&gt; &#13;
			_set_static_property_text(property, text.from_gtv(value));&#13;
		property_type.boolean -&gt; &#13;
			_set_static_property_boolean(property, boolean.from_gtv(value));&#13;
		property_type.byte_array -&gt;&#13;
			_set_static_property_byte_array(property, byte_array.from_gtv(value));&#13;
		property_type._enum -&gt;&#13;
			//TODO: handle strings also, e.g. "red" for Color enum&#13;
			_set_static_property_enum(property, enum_value.from_gtv(value)); &#13;
		property_type.account -&gt;&#13;
			//TODO: handle account id and rowid&#13;
			_set_static_property_account(property, ft3.account.from_gtv(value));&#13;
	}&#13;
}&#13;
&#13;
function _static_property(structure, name): static_property {&#13;
	return static_property @ { structure, name };&#13;
}&#13;
&#13;
function get_static_property(structure, property_name: name): gtv? {&#13;
	return _get_static_property(_static_property(structure, property_name));&#13;
}&#13;
&#13;
function _get_static_property(static_property): gtv? {&#13;
	when (static_property.type) {&#13;
		property_type.text -&gt;&#13;
			return _get_static_property_text(static_property)?.to_gtv();&#13;
		property_type.boolean -&gt;&#13;
			return _get_static_property_boolean(static_property)?.to_gtv();&#13;
		property_type.byte_array -&gt;&#13;
			return _get_static_property_byte_array(static_property)?.to_gtv();&#13;
		property_type.integer -&gt;&#13;
			return _get_static_property_integer(static_property)?.to_gtv();&#13;
		property_type._enum -&gt;&#13;
			return _get_static_property_enum(static_property)?.to_gtv();&#13;
		property_type.account -&gt;&#13;
			return _get_static_property_account(static_property)?.to_gtv();&#13;
		property_type.interface,&#13;
		property_type.structure -&gt;&#13;
			return _get_static_property_instance(static_property)?.to_gtv();			&#13;
		else -&gt; {&#13;
			// TODO: shouldn't happen. fix this!!! define static_property_type enum which doesn't have id and index types&#13;
			val type = static_property.type;&#13;
			throw("Cannot have a static property of type '" + type.name + "'");&#13;
			return null;&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function get_static_property_serialized(structure, property_name: name): gtv? {&#13;
	val property = _static_property(structure, property_name);&#13;
	&#13;
	return _get_static_property_serialized(property);&#13;
}&#13;
&#13;
function _get_static_property_serialized(static_property): gtv? {&#13;
	when (static_property.type) {&#13;
		property_type.integer -&gt;&#13;
			return _get_static_property_integer(static_property)?.to_gtv();&#13;
		property_type.text -&gt;&#13;
			return _get_static_property_text(static_property)?.to_gtv();&#13;
		property_type.boolean -&gt;&#13;
			return _get_static_property_boolean(static_property)?.to_gtv();&#13;
		property_type.byte_array -&gt;&#13;
			return _get_static_property_byte_array(static_property)?.to_gtv();&#13;
		property_type._enum -&gt;&#13;
			return _get_static_property_enum_serialized(static_property);			&#13;
		property_type.account -&gt;&#13;
			return _get_static_property_account_serialized(static_property);&#13;
		property_type.interface,&#13;
		property_type.structure -&gt;&#13;
			return _get_static_property_instance_serialized(static_property);&#13;
		else -&gt; {&#13;
			// TODO: shouldn't happen. fix this!!! define static_property_type enum which doesn't have id and index types&#13;
			val type = static_property.type;&#13;
			throw("Cannot have a static property of type '" + static_property.name + "'");&#13;
			return null;&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function unset_property_s(structure, name) {&#13;
	val property = static_property @ { .name == name, structure };&#13;
	&#13;
	require(property.optional == true, "Cannot un-set non-optional property '" + name + "'");&#13;
	&#13;
		when(property.type) {&#13;
		property_type.integer -&gt; unset_property_s_integer(property);&#13;
		property_type.text -&gt; unset_property_s_text(property);&#13;
		property_type.boolean -&gt; unset_property_s_bool(property);&#13;
	}&#13;
}&#13;
&#13;
function _create_structure_property(&#13;
	structure, &#13;
	name, &#13;
	prop, &#13;
	init_value: byte_array, &#13;
	property_type&#13;
): structure_property {	&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type,&#13;
		value = init_value&#13;
	);&#13;
	&#13;
	for (tag in prop.meta.tags) {&#13;
		_create_structure_property_meta_tag(property, tag);&#13;
	}&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
function _create_structure_property_meta_tag(structure_property, tag): structure_property_meta_tag {&#13;
	return create structure_property_meta_tag(&#13;
		structure_property,&#13;
		name = tag.name,&#13;
		value = tag.value.value&#13;
	);&#13;
}&#13;
&#13;
function _create_structure_property_meta_tags(structure_property, tags: list&lt;tag&gt;) {&#13;
	for (tag in tags) {&#13;
		_create_structure_property_meta_tag(structure_property, tag);&#13;
	}&#13;
}&#13;
&#13;
function _create_static_property_meta_tag(&#13;
	static_property, tag&#13;
): static_property_meta_tag {&#13;
	return create static_property_meta_tag(&#13;
		static_property,&#13;
		name = tag.name,&#13;
		value = tag.value.value&#13;
	);&#13;
}&#13;
&#13;
function _create_static_property_meta_tags(static_property, tags: list&lt;tag&gt;) {&#13;
	for (tag in tags) {&#13;
		_create_static_property_meta_tag(static_property, tag);&#13;
	}&#13;
}&#13;
&#13;
function find_structure_properties_by_meta_tag(&#13;
	structure, &#13;
	tag_name: name&#13;
): list&lt;structure_property&gt; {&#13;
	return (&#13;
		sp: structure_property,  &#13;
		spmt: structure_property_meta_tag&#13;
	) @* {&#13;
		sp.structure == structure,&#13;
		spmt.structure_property == sp,&#13;
		spmt.name == tag_name&#13;
	} (&#13;
		sp&#13;
	);&#13;
}&#13;
&#13;
function find_static_structure_properties_by_meta_tag(&#13;
	structure, tag_name: name&#13;
): list&lt;static_property&gt; {&#13;
	return (&#13;
		ssp: static_property,  &#13;
		sspmt: static_property_meta_tag&#13;
	) @* {&#13;
		ssp.structure == structure,&#13;
		sspmt.static_property == ssp,&#13;
		sspmt.name == tag_name&#13;
	} (&#13;
		ssp&#13;
	);&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/mapper.rell">
                                <string>&#13;
function map_structure(structure, map_definitions: list&lt;map_&gt;): map&lt;text, gtv?&gt; {&#13;
	val structure_map = map&lt;text, gtv?&gt;();&#13;
	&#13;
	for (map_definition in map_definitions) {&#13;
		var m = map&lt;name, gtv?&gt;();&#13;
		&#13;
		when (map_definition.map_type.type) {&#13;
			mapper_type.property_list -&gt; &#13;
				m = __structure.handle_property_list_mapping(structure, map_definition.map_type);&#13;
			mapper_type.all_properties -&gt;&#13;
				m = __structure.handle_all_properties_mapping(structure, map_definition.map_type);&#13;
			mapper_type.interface -&gt;&#13;
				m = __structure.handle_interfaces_mapping(structure, map_definition.map_type);&#13;
			mapper_type.instance_count -&gt;&#13;
				m = __structure.handle_instance_count_mapping(structure);&#13;
			else -&gt; {&#13;
				throw("Mapping '" + map_definition.map_type.type.name + "' not implemented");&#13;
			}&#13;
		}&#13;
		&#13;
		when (map_definition.map_property_type.type) {&#13;
			mapper_property_type.direct -&gt; &#13;
				structure_map.put_all(m);&#13;
			mapper_property_type.dict -&gt;&#13;
				structure_map[map_definition.map_property_type.name] &#13;
					= m.to_gtv();&#13;
			mapper_property_type.array -&gt;&#13;
				structure_map[map_definition.map_property_type.name] &#13;
					= _dict_to_array(m).to_gtv();&#13;
		}&#13;
	}&#13;
	&#13;
	return structure_map;&#13;
}&#13;
&#13;
namespace __structure {&#13;
	function handle_property_list_mapping(structure, map_type): map&lt;name, gtv?&gt; {&#13;
		require(map_type.type == mapper_type.property_list);&#13;
		val properties_map = map&lt;name, gtv?&gt;();&#13;
		&#13;
		for (property_name in map_type.names) {&#13;
			if (not properties_map.contains(property_name)) {&#13;
				properties_map[property_name] = get_static_property_serialized(structure, property_name); &#13;
			}&#13;
		}&#13;
		&#13;
		return properties_map;&#13;
	}&#13;
	&#13;
	function handle_all_properties_mapping(structure, map_type): map&lt;name, gtv?&gt; {&#13;
		require(map_type.type == mapper_type.all_properties);&#13;
		&#13;
		val properties = static_property @* { structure };&#13;
&#13;
		val properties_map = map&lt;name, gtv?&gt;();&#13;
		for (property in properties) {&#13;
			properties_map[property.name] = _get_static_property_serialized(property);&#13;
		}&#13;
		return properties_map;&#13;
	}&#13;
	&#13;
	function handle_interfaces_mapping(structure, map_type): map&lt;name, gtv?&gt; {&#13;
		require(map_type.type == mapper_type.interface);&#13;
		&#13;
		val properties = _get_static_properties_of_interfaces(&#13;
			structure, &#13;
			Interfaces(map_type.names)&#13;
		);&#13;
		&#13;
		val properties_map = map&lt;name, gtv?&gt;();&#13;
		for (property in properties) {&#13;
			properties_map[property.name] = _get_static_property_serialized(property);&#13;
		} &#13;
		return properties_map;&#13;
	}&#13;
	&#13;
	function handle_instance_count_mapping(structure): map&lt;name, gtv?&gt; {&#13;
		val count = get_instances_count(structure);&#13;
		val max_count = get_instances_max_count(structure);&#13;
		&#13;
		val count_map = map&lt;text, gtv?&gt;();&#13;
		count_map["count"] = count.to_gtv();&#13;
		&#13;
		if (max_count??) {&#13;
			count_map["max"] = max_count.to_gtv();&#13;
		}&#13;
		&#13;
		return count_map;&#13;
	}&#13;
}&#13;
&#13;
function structure_values_integer(structure): map&lt;text, gtv?&gt; {&#13;
	val properties = static_property @* {&#13;
		structure,&#13;
		.type == property_type.integer&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	for (property in properties) {&#13;
		val value = static_property_value_integer @? { property }.value?.to_gtv();&#13;
		property_value_map[property.name] = value;&#13;
	}&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function structure_values_text(structure): map&lt;text, gtv?&gt; {&#13;
	val properties = static_property @* {&#13;
		structure,&#13;
		.type == property_type.text&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	for (property in properties) {&#13;
		val value = static_property_value_text @? { property }.value?.to_gtv();&#13;
		property_value_map[property.name] = value;&#13;
	}&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function structure_values_byte_array(structure): map&lt;text, gtv?&gt; {&#13;
	val properties = static_property @* {&#13;
		structure,&#13;
		.type == property_type.byte_array&#13;
	};&#13;
	&#13;
	val property_value_map = map&lt;text, gtv?&gt;();&#13;
	for (property in properties) {&#13;
		val value = static_property_value_byte_array @? { property }.value?.to_gtv();&#13;
		property_value_map[property.name] = value;&#13;
	}&#13;
	return property_value_map;&#13;
}&#13;
&#13;
function structure_value_count(structure): map&lt;text, gtv&gt; {&#13;
	val count_map = map&lt;text, gtv&gt;();&#13;
	val values = map&lt;text, gtv?&gt;();&#13;
	&#13;
	values["count"] = get_instances_count(structure).to_gtv();&#13;
	&#13;
	count_map["_count"] = values.to_gtv();&#13;
	return count_map;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/structure/operations/dev/module.rell">
                                <string>import ^^^.instance;&#13;
import ^^^.structure;&#13;
&#13;
//operation def_structure(name, interfaces_names: list&lt;text&gt;, property_list: list&lt;structure.property&gt;) {&#13;
//	structure.def_structure(name, interfaces_names, property_list);&#13;
//}&#13;
&#13;
//operation new_instance(structure_name: text, property_list: list&lt;structure.property&gt;) {&#13;
//	instance.new_instance(structure_name, property_list);&#13;
//}</string>
                            </entry>
                            <entry key="lib/structure/operations/module.rell">
                                <string></string>
                            </entry>
                            <entry key="lib/structure/private_functions.rell">
                                <string>&#13;
function _get_id_property(props: map&lt;name, prop&gt;): name? {&#13;
	var id_property_names = list&lt;name&gt;();&#13;
	&#13;
	for ((name, prop) in props) {&#13;
		if (prop.prop_type_struct.type == property_type.id) {&#13;
			id_property_names.add(name);&#13;
		}&#13;
	}&#13;
	&#13;
	require(&#13;
		id_property_names.size() &lt;= 1, &#13;
		"Found " + id_property_names.size() + " properties of type ID"&#13;
	);&#13;
	&#13;
	return if (id_property_names.size() == 1) id_property_names[0] else null; &#13;
}</string>
                            </entry>
                            <entry key="lib/structure/require_functions.rell">
                                <string>&#13;
function _require_static_property_not_readonly(static_property) {&#13;
	require(&#13;
		not static_property.readonly,&#13;
		"Static property '" + static_property.name + "' is read-only"&#13;
	);&#13;
}&#13;
&#13;
function _require_static_property_structure_or_interface(static_property) {&#13;
	require(&#13;
		static_property.type == property_type.structure &#13;
			or &#13;
		static_property.type == property_type.interface,&#13;
		"Static property '" + static_property.name + "' is not an interface or a structure"&#13;
	);&#13;
}&#13;
&#13;
function _require_instance_is_of_valid_type(static_property, instance) {	&#13;
	_require_static_property_structure_or_interface(static_property);&#13;
	&#13;
	val name = static_property.name;&#13;
	val type = static_property.type;&#13;
	&#13;
	when(type) {&#13;
		property_type.interface -&gt; {&#13;
			val interface = static_property_interface @ { &#13;
				static_property&#13;
			}.interface;&#13;
			&#13;
			require(&#13;
				structure_implements_interface(instance.structure, interface),&#13;
				"Static property '" + name + "' is not of '" + interface.name + "' type."&#13;
			);&#13;
		}&#13;
		property_type.structure -&gt; {&#13;
			val structure = static_property_structure @ { &#13;
				static_property&#13;
			}.structure;&#13;
			&#13;
			require(&#13;
				instance.structure == structure,&#13;
				"Static property '" + name + "' is not of '" + structure.name + "' type."&#13;
			);&#13;
		}&#13;
	}&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/structure/structure.rell">
                                <string>/* instance properties */&#13;
&#13;
entity structure_property_structure {&#13;
	key structure_property, structure;&#13;
}&#13;
&#13;
function _create_structure_property_structure(structure, name, prop): structure_property {	&#13;
	val structure_prop = strct.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val property = create structure_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.structure,&#13;
		value = x""&#13;
	);&#13;
	&#13;
	create structure_property_structure(&#13;
		property,&#13;
		structure_prop.structure&#13;
	);&#13;
&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
/* static properties */&#13;
&#13;
entity static_property_structure {&#13;
	key static_property, structure;&#13;
}&#13;
&#13;
function _create_static_property_structure(structure, name, prop, init_value: gtv?) {&#13;
	val structure_prop = strct.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val property = create static_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.structure&#13;
	);&#13;
	&#13;
	_create_static_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	create static_property_structure(&#13;
		property,&#13;
		structure_prop.structure		&#13;
	);&#13;
	&#13;
	&#13;
	require(&#13;
		prop.optional.value == true or init_value != null,&#13;
		"Non-optional '" + structure_prop.structure.name +"' type property '" + name + "' is not initialized"&#13;
	); &#13;
	&#13;
	if (init_value??) {&#13;
		if (is_integer(init_value)) {&#13;
			val instance = instance @ { rowid.from_gtv(init_value) };&#13;
			&#13;
			require(&#13;
				instance.structure == structure_prop.structure,&#13;
				"Trying to assign an instance of type '" + instance.structure.name + &#13;
				"' to a property '" + name + "' of type '" + structure_prop.structure.name + "'"&#13;
			);&#13;
			&#13;
			create static_property_value_instance(&#13;
				property,&#13;
				instance&#13;
			);&#13;
		} else if(is_map(init_value)) {&#13;
			val properties = map&lt;text, gtv&gt;.from_gtv(init_value);&#13;
			val s = static_property_structure @ { property }.structure;&#13;
			val instance = new_(instance_(s, init(properties)));&#13;
			create static_property_value_instance(&#13;
				property,&#13;
				instance&#13;
			);&#13;
		} else {&#13;
			throw("Unsupported argument type");&#13;
		}&#13;
	}&#13;
}</string>
                            </entry>
                            <entry key="lib/structure/text.rell">
                                <string>/* instance properties */&#13;
&#13;
function _create_structure_property_text(structure, name, prop): structure_property {&#13;
	val txt_props = txt.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val v = if (txt_props.value != null) txt_props.value!!.to_gtv().to_bytes() else x"";&#13;
	&#13;
	val property = create structure_property (&#13;
		name,&#13;
		structure,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.text,&#13;
		value = v&#13;
	);&#13;
		&#13;
	_create_structure_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	return property;&#13;
}&#13;
&#13;
/* static properties */&#13;
&#13;
entity static_property_value_text {&#13;
	key static_property;&#13;
	mutable value: text;&#13;
}&#13;
&#13;
function set_static_property_text(structure, property_name: name, value: text) {&#13;
	_set_static_property_text(_static_property(structure, property_name), value);&#13;
}&#13;
&#13;
function _set_static_property_text(static_property, value: text) {&#13;
	val property_value = static_property_value_text @? { static_property };&#13;
&#13;
	if (property_value??) {&#13;
		property_value.value = value;&#13;
	} else {&#13;
		create static_property_value_text(&#13;
			static_property,&#13;
			value&#13;
		);&#13;
	}&#13;
}&#13;
&#13;
function get_static_property_text(structure, name): text? {&#13;
	return _get_static_property_text(_static_property(structure, name));&#13;
}&#13;
&#13;
function _get_static_property_text(static_property): text?{&#13;
	require(static_property.type == property_type.text);&#13;
	return static_property_value_text @? { &#13;
		static_property&#13;
	}.value;&#13;
}&#13;
&#13;
function unset_property_s_text(static_property) {&#13;
	delete static_property_value_text @ { static_property };&#13;
}&#13;
&#13;
function create_static_property_text(&#13;
	structure, &#13;
	name, &#13;
	prop, &#13;
	init_value: gtv?&#13;
): static_property {&#13;
	val property = create static_property(&#13;
		structure,&#13;
		name = name,&#13;
		readonly = prop.readonly.value,&#13;
		optional = prop.optional.value,&#13;
		type = property_type.text&#13;
	);&#13;
	&#13;
	_create_static_property_meta_tags(property, prop.meta.tags);&#13;
	&#13;
	val txt_def = txt.from_gtv(prop.prop_type_struct.type_gtv);&#13;
	&#13;
	val value = txt_def.value;&#13;
	val init_value_text = if (init_value??) text.from_gtv(init_value) else null;&#13;
	&#13;
	require(&#13;
		value != null or init_value_text != null or prop.optional.value == true,&#13;
		"Non-optional text property '" + name + "' is not initialized"&#13;
	); &#13;
	&#13;
	require(&#13;
		prop.readonly.value == false&#13;
			or&#13;
		((value == null or init_value_text == null) and prop.readonly.value == true),&#13;
		"Read-only text property '" + name + "' can be initialized only once"&#13;
	);&#13;
	&#13;
	val v = init_value_text ?: value;&#13;
	&#13;
	if (v??) {&#13;
		create static_property_value_text(&#13;
			property,&#13;
			v&#13;
		);&#13;
	}&#13;
	&#13;
	return property;&#13;
}</string>
                            </entry>
                            <entry key="main.rell">
                                <string>module;&#13;
&#13;
import rell_modules.ft3.operations.dev_op_account;&#13;
import rell_modules.ft3.operations.dev_op_asset;&#13;
import rell_modules.ft3.operations.dev_op_balance;&#13;
&#13;
namespace game{&#13;
  import ^.game;&#13;
}</string>
                            </entry>
                            <entry key="rell_modules/ft3/account/auth_basic.rell">
                                <string>// Auth type:&#13;
&#13;
// "S" - single-sig&#13;
// "M" - multi-sig&#13;
&#13;
struct single_sig_args {&#13;
       flags: set&lt;text&gt;;&#13;
       pubkey;&#13;
}&#13;
&#13;
struct multi_sig_args {&#13;
       flags: set&lt;text&gt;;&#13;
       signatures_required: integer;&#13;
       pubkeys: list&lt;pubkey&gt;;&#13;
}&#13;
&#13;
function check_single_sig_auth(args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): boolean {&#13;
    require(participants.size() == 1);&#13;
    val ss_args = single_sig_args.from_bytes(args);&#13;
    return&#13;
          ss_args.flags.contains_all(required_flags)&#13;
            and&#13;
          is_signer(participants[0]);&#13;
}&#13;
&#13;
function check_multi_sig_auth(args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): boolean {&#13;
   val multi_sign_args = multi_sig_args.from_bytes(args);&#13;
   if (not (multi_sign_args.flags.contains_all(required_flags))) return false;&#13;
   var num_sign = multi_sign_args.signatures_required;&#13;
   for(s in participants) {&#13;
      if(is_signer(s)) {&#13;
          num_sign -= 1;&#13;
          if(num_sign &lt; 1) {return true;}&#13;
      }&#13;
   }&#13;
   return false;&#13;
}&#13;
&#13;
function check_auth_args (a_t: text, args: byte_array, participants: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): boolean {&#13;
    return when (a_t) {&#13;
        "S" -&gt; check_single_sig_auth(args, participants, required_flags);&#13;
        "M" -&gt; check_multi_sig_auth(args, participants, required_flags);&#13;
        else -&gt; false;&#13;
    };&#13;
}&#13;
&#13;
&#13;
&#13;
function require_auth (account, descriptor_id: byte_array, required_flags: list&lt;text&gt;) {&#13;
   val account_auth_descriptor = account_auth_descriptor @ {&#13;
     account,&#13;
     .descriptor_id == descriptor_id&#13;
   };&#13;
	&#13;
	require(is_valid(account_auth_descriptor));&#13;
	&#13;
   	require(&#13;
		check_auth_args(&#13;
       		account_auth_descriptor.auth_type,&#13;
       		account_auth_descriptor.args,&#13;
       		auth_descriptor_participant @* { account_auth_descriptor } ( .id ),&#13;
       		required_flags&#13;
		)&#13;
   );&#13;
   &#13;
   update_auth_descriptor_rule_variables(account_auth_descriptor);&#13;
   delete_expired_auth_descriptors(account);&#13;
}&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/account/auth_descriptor_rule.rell">
                                <string>&#13;
enum rule_variable {&#13;
	block_height,&#13;
	block_time,&#13;
	op_count&#13;
}&#13;
&#13;
enum rule_operator {&#13;
	lt,&#13;
	le,&#13;
	eq,&#13;
	ge,&#13;
	gt&#13;
}&#13;
&#13;
struct rule_expression {&#13;
	variable: text;&#13;
	operator: text;&#13;
	value: gtv;&#13;
}&#13;
&#13;
entity auth_descriptor_rule_variable {&#13;
	key account_auth_descriptor, name;&#13;
	mutable value: byte_array;&#13;
}&#13;
&#13;
function is_valid(auth_descriptor: account_auth_descriptor): boolean {&#13;
	// check if rules is null (encoded null is equal to 0xa0020500)&#13;
	if (auth_descriptor.rules == x'a0020500') {&#13;
		return true;&#13;
	}&#13;
	&#13;
	return is_rule_valid(&#13;
		gtv.from_bytes(auth_descriptor.rules), &#13;
		load_variables(auth_descriptor)&#13;
	);&#13;
}&#13;
&#13;
function is_rule_valid(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {&#13;
	val parameters = list&lt;gtv&gt;.from_gtv(rule);&#13;
	val operator = text.from_gtv(parameters[1]);&#13;
	&#13;
	if (operator == "and") {&#13;
		return handle_composed_rule(rule, variables);&#13;
	} else {&#13;
		return handle_single_rule(rule, variables);&#13;
	}&#13;
}&#13;
&#13;
function handle_single_rule(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {&#13;
	return evaluate_int_variable_rule(&#13;
		rule_expression.from_gtv(rule), &#13;
		variables&#13;
	);	&#13;
}&#13;
&#13;
 &#13;
function handle_composed_rule(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {&#13;
	val parameters = list&lt;gtv&gt;.from_gtv(rule);&#13;
	val operator = text.from_gtv(parameters[1]);&#13;
	if (operator == "and") {&#13;
		return is_rule_valid(parameters[0], variables) and is_rule_valid(parameters[2], variables);&#13;
	} else {&#13;
		return false;&#13;
	}&#13;
}&#13;
&#13;
&#13;
&#13;
function is_active(account_auth_descriptor): boolean {&#13;
	if (account_auth_descriptor.rules == x'a0020500') {&#13;
		return true;&#13;
	}&#13;
	&#13;
	return is_rule_active(gtv.from_bytes(account_auth_descriptor.rules), map&lt;text, gtv&gt;());&#13;
}&#13;
&#13;
&#13;
function is_rule_active(r: gtv, variables: map&lt;text, gtv&gt;): boolean {&#13;
	val parameters = list&lt;gtv&gt;.from_gtv(r);&#13;
	val operator = text.from_gtv(parameters[1]);&#13;
	when (operator) {&#13;
		"and" -&gt; {&#13;
			return is_rule_active(parameters[0], variables) and is_rule_active(parameters[2], variables);&#13;
		}&#13;
		else -&gt; {&#13;
			return is_simple_rule_active(r, variables);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
function is_simple_rule_active(rule: gtv, variables: map&lt;text, gtv&gt;): boolean {&#13;
	val parameters = list&lt;gtv&gt;.from_gtv(rule);&#13;
	val variable_name = text.from_gtv(parameters[0]);&#13;
	when (rule_variable.value(variable_name)) {&#13;
		rule_variable.block_height -&gt; {&#13;
			return is_block_height_rule_active(rule);&#13;
		}&#13;
		rule_variable.block_time -&gt; {&#13;
			return is_block_time_rule_active(rule);&#13;
		}		&#13;
		rule_variable.op_count -&gt; {&#13;
			return is_op_count_rule_active(rule);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
/*&#13;
 *  Variables&#13;
 */&#13;
&#13;
function evaluate_int_variable_rule(rule: rule_expression, variables: map&lt;text, gtv&gt;): boolean {&#13;
	val variable = rule_variable.value(rule.variable);&#13;
	val operator = rule_operator.value(rule.operator);&#13;
	val current_value = variable_value(variable, variables);&#13;
	val defined_value = integer.from_gtv(rule.value);&#13;
&#13;
	when (operator) {&#13;
		rule_operator.lt -&gt; {&#13;
			return current_value &lt; defined_value;&#13;
		}&#13;
		rule_operator.le -&gt; {&#13;
			return current_value &lt;= defined_value;&#13;
		}&#13;
		rule_operator.eq -&gt; {&#13;
			return current_value == defined_value;&#13;
		}&#13;
		rule_operator.ge -&gt; {&#13;
			return current_value &gt;= defined_value;&#13;
		}&#13;
		rule_operator.gt -&gt; {&#13;
			return current_value &gt; defined_value;&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
&#13;
/*&#13;
 * Called from _add_auth_descriptor function&#13;
 */&#13;
function setup_auth_descriptor_variables(account_auth_descriptor) {&#13;
	&#13;
	if (account_auth_descriptor.rules == x'a0020500') {&#13;
		return;&#13;
	} &#13;
	&#13;
	val variables = get_variable_names_set(gtv.from_bytes(account_auth_descriptor.rules));&#13;
	&#13;
	for (variable in variables) {&#13;
		when (variable) {&#13;
			rule_variable.op_count.name -&gt; {&#13;
				create auth_descriptor_rule_variable(&#13;
					account_auth_descriptor,&#13;
					name = variable,&#13;
					value = op_count_variable_initial_value().to_bytes()&#13;
				);&#13;
			}&#13;
		}&#13;
	}&#13;
}&#13;
 &#13;
function update_variables(account_auth_descriptor, variables: map&lt;text, gtv&gt;) {&#13;
	for ((name, value) in variables) {&#13;
		val variable = auth_descriptor_rule_variable @ { account_auth_descriptor, name };&#13;
		val int_value = integer.from_gtv(value);&#13;
		&#13;
		when (name) {&#13;
			rule_variable.op_count.name -&gt; {&#13;
				variable.value = (int_value + 1).to_gtv().to_bytes();&#13;
			}&#13;
		}&#13;
	}&#13;
}&#13;
 &#13;
function variable_value(variable: rule_variable, variables: map&lt;text, gtv&gt;): integer {&#13;
	when (variable) {&#13;
		rule_variable.block_height -&gt; {&#13;
			return op_context.block_height;&#13;
		}&#13;
		rule_variable.block_time -&gt; {&#13;
			return op_context.last_block_time;&#13;
		}&#13;
		rule_variable.op_count -&gt; {&#13;
			return integer.from_gtv(variables[rule_variable.op_count.name]);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
/*&#13;
 * Analyze the rules before assigning them to an authenticator descriptor&#13;
 */&#13;
 function analyze_auth_descriptor_rules(rules: gtv, hop: integer) {&#13;
 	require(hop&lt;3, "too many rules");&#13;
 	val rules_bytes = rules.to_bytes(); &#13;
 	if (rules_bytes == x'a0020500') {&#13;
		return;&#13;
	}&#13;
	&#13;
 	val params = list&lt;gtv&gt;.from_gtv(rules);&#13;
 	require(params.size() &lt;=3);&#13;
 	&#13;
 	val operator = text.from_gtv(params[1]);&#13;
 	if(operator == "and") {&#13;
 		analyze_auth_descriptor_rules(params[0], hop+1); &#13;
 		analyze_auth_descriptor_rules(params[2], hop+1);&#13;
 	} 	&#13;
 	&#13;
	return;&#13;
 }&#13;
&#13;
/*&#13;
 * Returns set of variable names used in a rule&#13;
 */&#13;
function get_variable_names_set(rules: gtv): set&lt;text&gt; {&#13;
	val parameters = list&lt;gtv&gt;.from_gtv(rules);&#13;
	val operator = text.from_gtv(parameters[1]);&#13;
	var vars = set&lt;text&gt;();&#13;
	if (operator == "and") {&#13;
		vars.add_all(get_variable_names_set(parameters[0]));&#13;
		vars.add_all(get_variable_names_set(parameters[2]));&#13;
	} else {&#13;
		vars.add(text.from_gtv(parameters[0]));&#13;
	}&#13;
	return vars;&#13;
} &#13;
&#13;
function load_variables(account_auth_descriptor): map&lt;text, gtv&gt; {&#13;
	val variables = auth_descriptor_rule_variable @* { account_auth_descriptor };&#13;
	&#13;
	val variables_map = map&lt;text, gtv&gt;();&#13;
	for (variable in variables) {&#13;
		variables_map[variable.name] = gtv.from_bytes(variable.value);&#13;
	}&#13;
	&#13;
	return variables_map;&#13;
}&#13;
&#13;
function update_auth_descriptor_rule_variables(account_auth_descriptor) {&#13;
	val variables = load_variables(account_auth_descriptor);&#13;
	update_variables(account_auth_descriptor, variables);&#13;
}&#13;
&#13;
/*&#13;
 * auth descriptor cleanup&#13;
 */&#13;
&#13;
function delete_expired_auth_descriptors(account) {&#13;
	val auth_descriptors = account_auth_descriptor @* { account };&#13;
	&#13;
	for (auth_descriptor in auth_descriptors) {&#13;
		if (not (is_active(auth_descriptor) and is_valid(auth_descriptor))) {&#13;
			_delete_auth_descriptor(auth_descriptor);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
/****************************************************************************************&#13;
 *                                     block_time                                       *&#13;
 ****************************************************************************************/&#13;
&#13;
function is_block_time_rule_active(r: gtv): boolean {&#13;
	val parameters = list&lt;gtv&gt;.from_gtv(r);&#13;
	val operator = rule_operator.value(text.from_gtv(parameters[1]));&#13;
	val value = integer.from_gtv(parameters[2]);&#13;
	when (operator) {&#13;
		rule_operator.gt -&gt; {&#13;
			return op_context.last_block_time &gt; value;&#13;
		}&#13;
		rule_operator.ge,&#13;
		rule_operator.eq -&gt; {&#13;
			return op_context.last_block_time &gt;= value;&#13;
		}&#13;
		else -&gt; {&#13;
			return true;&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
&#13;
/****************************************************************************************&#13;
 *                                  block_height                                        *&#13;
 ****************************************************************************************/&#13;
&#13;
function is_block_height_rule_active(r: gtv): boolean {&#13;
	val parameters = list&lt;gtv&gt;.from_gtv(r);&#13;
	val operator = rule_operator.value(text.from_gtv(parameters[1]));&#13;
	val value = integer.from_gtv(parameters[2]);&#13;
	when (operator) {&#13;
		rule_operator.gt -&gt; {&#13;
			return op_context.block_height &gt; value;&#13;
		}&#13;
		rule_operator.ge,&#13;
		rule_operator.eq -&gt; {&#13;
			return op_context.block_height &gt;= value;&#13;
		}&#13;
		else -&gt; {&#13;
			return true;&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
&#13;
/****************************************************************************************&#13;
 *                                     op_count                                         *&#13;
 ****************************************************************************************/&#13;
 &#13;
 function op_count_variable_initial_value(): gtv {&#13;
 	return (1).to_gtv();&#13;
 }&#13;
 &#13;
 function is_op_count_rule_active(rule: gtv): boolean {&#13;
 	return true;&#13;
 }</string>
                            </entry>
                            <entry key="rell_modules/ft3/account/module.rell">
                                <string>@mount('ft3')&#13;
module;&#13;
&#13;
import core: ^.core;&#13;
&#13;
struct auth_descriptor {&#13;
    auth_type: text;&#13;
    participants: list&lt;byte_array&gt;;&#13;
    args: list&lt;gtv&gt;;&#13;
    rules: gtv;&#13;
}&#13;
&#13;
entity account {&#13;
    key id: byte_array;&#13;
}&#13;
&#13;
entity account_meta {&#13;
    meta_key: text;&#13;
    value: byte_array;&#13;
    index account, meta_key;&#13;
    index meta_key, value;&#13;
}&#13;
&#13;
entity account_auth_descriptor {&#13;
     descriptor_id: byte_array;&#13;
     key account, descriptor_id;&#13;
     index descriptor_id;&#13;
     auth_type: text;&#13;
     args: byte_array;&#13;
     rules: byte_array;&#13;
}&#13;
&#13;
entity auth_descriptor_participant {&#13;
    key account_auth_descriptor, id: byte_array;&#13;
}&#13;
&#13;
&#13;
// rate limiter&#13;
entity rl_state {&#13;
    key account;&#13;
    mutable points: integer;&#13;
    mutable last_update: timestamp;&#13;
    mutable max_points: integer;&#13;
    mutable recovery_time: timestamp;&#13;
}&#13;
&#13;
function _add_auth_descriptor (account, auth_descriptor) {&#13;
     val descriptor_id = auth_descriptor.hash();&#13;
     &#13;
     analyze_auth_descriptor_rules(auth_descriptor.rules, 0);&#13;
     &#13;
     val account_auth_descriptor = create account_auth_descriptor (&#13;
        account, descriptor_id,&#13;
        auth_descriptor.auth_type,&#13;
        args = auth_descriptor.args.to_gtv().to_bytes(),&#13;
        rules = auth_descriptor.rules.to_gtv().to_bytes()&#13;
     );&#13;
     &#13;
     for (participant in auth_descriptor.participants) {&#13;
        require(is_signer(participant));&#13;
        create auth_descriptor_participant(account_auth_descriptor, id = participant);&#13;
     }&#13;
     &#13;
     setup_auth_descriptor_variables(account_auth_descriptor);&#13;
}&#13;
&#13;
function _delete_auth_descriptor(auth_descriptor: account_auth_descriptor) {&#13;
	delete auth_descriptor_rule_variable @* { auth_descriptor };&#13;
	delete auth_descriptor_participant @* { auth_descriptor };&#13;
	delete auth_descriptor;&#13;
}&#13;
&#13;
function _delete_all_auth_descriptors_exclude(account, auth_descriptor_id: byte_array) {&#13;
	delete (adrv: auth_descriptor_rule_variable, ad: account_auth_descriptor) @* {&#13;
		ad.account == account, ad.descriptor_id != auth_descriptor_id, adrv.account_auth_descriptor == ad		&#13;
	};&#13;
	&#13;
	delete (adp: auth_descriptor_participant, ad: account_auth_descriptor) @* {&#13;
        ad.account == account and ad.descriptor_id != auth_descriptor_id and adp.account_auth_descriptor == ad&#13;
    };&#13;
&#13;
    delete account_auth_descriptor @* {&#13;
       .account == account,&#13;
       .descriptor_id != auth_descriptor_id&#13;
    };&#13;
}&#13;
&#13;
function create_account_with_auth (auth_descriptor): byte_array {&#13;
     val id = auth_descriptor.hash();&#13;
     val acc = create account (id);&#13;
     _add_auth_descriptor(&#13;
        acc, auth_descriptor&#13;
     );&#13;
     val max_points = core.my_blockchain_info.rate_limit_max_points;&#13;
     val recovery_time = core.my_blockchain_info.rate_limit_recovery_time;&#13;
     val points_at_start = core.my_blockchain_info.rate_limit_points_at_account_creation;&#13;
     &#13;
	create rl_state(acc, .points = points_at_start, .last_update = op_context.last_block_time, max_points, recovery_time);&#13;
    &#13;
    return id;&#13;
}&#13;
&#13;
function auth_and_log(account_id: byte_array, auth_descriptor_id: byte_array, required_flags: list&lt;text&gt;): account {&#13;
	val account = account @ { .id == account_id };&#13;
	rate_limit(account);&#13;
	require_auth(account, auth_descriptor_id, required_flags);&#13;
	return account;&#13;
}&#13;
&#13;
query is_auth_descriptor_valid(account_id: byte_array, auth_descriptor_id: byte_array) {&#13;
    return is_valid(account_auth_descriptor @ {&#13;
        .account.id == account_id,&#13;
        .descriptor_id == auth_descriptor_id&#13;
    });&#13;
}&#13;
&#13;
query get_account_auth_descriptors(id: byte_array) {&#13;
    return account_auth_descriptor @* {&#13;
        .account.id == id&#13;
    } (&#13;
        id = .descriptor_id,&#13;
        type = .auth_type,&#13;
        args = .args&#13;
    );&#13;
}&#13;
&#13;
query get_account_by_id(id: byte_array) {&#13;
    return account @? { id } ( .id );&#13;
}&#13;
&#13;
query get_account_by_auth_descriptor(auth_descriptor) {&#13;
    return account @? { .id == auth_descriptor.hash() } ( .id );&#13;
}&#13;
&#13;
query get_accounts_by_participant_id(id: byte_array) {&#13;
    return auth_descriptor_participant @* { id } ( .account_auth_descriptor.account.id );&#13;
}&#13;
&#13;
query get_accounts_by_auth_descriptor_id(descriptor_id: byte_array) {&#13;
    return account_auth_descriptor @* { descriptor_id } ( .account.id );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/account/rate_limit.rell">
                                <string>import ^.core;&#13;
&#13;
&#13;
function rate_limit (account) {&#13;
	if(core.my_blockchain_info.rate_limit_active == false ) return;&#13;
    val max_counter = core.my_blockchain_info.rate_limit_max_points;&#13;
    val recovery_time = core.my_blockchain_info.rate_limit_recovery_time;&#13;
    val stat = rl_state@{account} (.points, .last_update);&#13;
    val delta = op_context.last_block_time - stat.last_update;&#13;
    var got_points = 0;&#13;
    var update_time = stat.last_update;&#13;
&#13;
    if (delta &gt; recovery_time)&#13;
    {&#13;
        got_points = delta / recovery_time;&#13;
        update_time = stat.last_update + got_points * recovery_time;&#13;
        if (got_points + stat.points &gt; max_counter) {&#13;
            got_points = max_counter - stat.points;&#13;
            // if user is at maximum reset his &#13;
            // timer&#13;
            update_time = op_context.last_block_time;&#13;
        }&#13;
    }&#13;
    &#13;
    require(stat.points + got_points &gt; 0);&#13;
    &#13;
    update rl_state@{account} (&#13;
        .points += got_points - 1,&#13;
        .last_update = update_time&#13;
    );&#13;
}&#13;
&#13;
&#13;
query get_account_rate_limit_last_update(account_id: byte_array) {&#13;
	if(core.my_blockchain_info.rate_limit_active == false ) return (points = 0, last_update = 0);&#13;
	val t= rl_state@{.account.id == account_id}&#13;
	(&#13;
		.points, &#13;
		.last_update&#13;
	);&#13;
	&#13;
	return t;&#13;
}&#13;
&#13;
query get_last_timestamp(): integer {&#13;
	return (block@{.timestamp&gt;0}(@sort_desc .timestamp) limit 1);&#13;
}</string>
                            </entry>
                            <entry key="rell_modules/ft3/core/asset.rell">
                                <string>import acc: ^.account;&#13;
&#13;
entity asset {&#13;
    id: byte_array;&#13;
    key id;&#13;
    name;&#13;
    issuing_chain_rid: byte_array;&#13;
}&#13;
&#13;
entity balance {&#13;
    key acc.account, asset;&#13;
    mutable amount: integer = 0;&#13;
}&#13;
&#13;
function ensure_balance(acc.account, asset): balance {&#13;
    val balance = balance @? {asset, account};&#13;
    if (balance != null) {&#13;
       return balance;&#13;
    }&#13;
    else return create balance(account, asset, amount = 0);&#13;
}&#13;
&#13;
function register_asset (name, issuing_chain_rid: byte_array): asset {&#13;
   val id = (name, issuing_chain_rid).hash();&#13;
   return create asset (id, name, issuing_chain_rid);&#13;
}&#13;
&#13;
function _get_asset_balances(account_id: byte_array): list&lt;(id:byte_array,name:text,amount:integer,chain_id:byte_array)&gt; {&#13;
    return balance @* { .account.id == account_id } (&#13;
      id = .asset.id,&#13;
      name = .asset.name,&#13;
      amount = .amount,&#13;
      chain_id = .asset.issuing_chain_rid&#13;
    );&#13;
}&#13;
&#13;
query get_asset_balances(account_id: byte_array) {&#13;
    return _get_asset_balances(account_id);&#13;
}&#13;
&#13;
query get_asset_balance(account_id: byte_array, asset_id: byte_array) {&#13;
    return balance @? {&#13;
        .account.id == account_id,&#13;
        .asset.id == asset_id&#13;
    } (&#13;
        id = .asset.id,&#13;
        name = .asset.name,&#13;
        amount = .amount,&#13;
        chain_id = .asset.issuing_chain_rid&#13;
    );&#13;
}&#13;
&#13;
query get_asset_by_name(name) {&#13;
    return asset @* { name } (&#13;
        .id,&#13;
        .name,&#13;
        .issuing_chain_rid&#13;
    );&#13;
    &#13;
}&#13;
&#13;
query get_asset_by_id(asset_id: byte_array) {&#13;
	return asset@{&#13;
		.id == asset_id&#13;
	}(&#13;
		id = .id,&#13;
		name = .name,&#13;
		issuing_chain_rid = .issuing_chain_rid&#13;
		&#13;
	);&#13;
}&#13;
&#13;
query get_all_assets() {&#13;
	return asset@*{}(&#13;
		id = .id,&#13;
		name = .name,&#13;
		issuing_chain_rid = .issuing_chain_rid	&#13;
	);&#13;
}</string>
                            </entry>
                            <entry key="rell_modules/ft3/core/dev_op.rell">
                                <string>module;&#13;
&#13;
import ft3: ^^.core;&#13;
import acc: ^^.account;&#13;
&#13;
object dev_state {&#13;
   mutable allow_dev_ops: boolean = true;&#13;
}&#13;
&#13;
function require_dev() {&#13;
    require(dev_state.allow_dev_ops);&#13;
}&#13;
&#13;
function dev_give_points_(account: acc.account, amount: integer) {&#13;
	require_dev();&#13;
	update acc.rl_state@{account}(.points += amount);&#13;
}</string>
                            </entry>
                            <entry key="rell_modules/ft3/core/history.rell">
                                <string>import acc: ^.account;&#13;
&#13;
@log entity payment_history_entry {&#13;
    index acc.account, asset;&#13;
    delta: integer;&#13;
&#13;
    // helps to locate exact position of payment entry in transaction&#13;
    op_index: integer;&#13;
    is_input: boolean;&#13;
    entry_index: integer;&#13;
}&#13;
&#13;
query get_payment_history(account_id: byte_array, after_block: integer) {&#13;
    return payment_history_entry @* {&#13;
        acc.account @ { account_id },&#13;
        .transaction.block.block_height &gt; after_block&#13;
    } (&#13;
        delta = .delta,&#13;
        asset = .asset.name,&#13;
        asset_id = .asset.id,&#13;
        is_input = .is_input,&#13;
        timestamp = .transaction.block.timestamp,&#13;
        block_height = .transaction.block.block_height,&#13;
        entry_index = .entry_index,&#13;
        tx_rid = .transaction.tx_rid,&#13;
        tx_data = .transaction.tx_data&#13;
    );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/core/module.rell">
                                <string>@mount('ft3')&#13;
module;&#13;
&#13;
struct module_args {&#13;
	my_blockchain_name: text;&#13;
	my_blockchain_website: text;&#13;
	my_blockchain_description: text;&#13;
	rate_limit_active: boolean;&#13;
	rate_limit_max_points: integer;&#13;
    rate_limit_recovery_time: integer;&#13;
    rate_limit_points_at_account_creation: integer;    &#13;
}</string>
                            </entry>
                            <entry key="rell_modules/ft3/core/my_blockchain_info.rell">
                                <string>&#13;
object my_blockchain_info {&#13;
    mutable name: text = chain_context.args.my_blockchain_name;&#13;
    mutable website: text = chain_context.args.my_blockchain_website;&#13;
    mutable description: text = chain_context.args.my_blockchain_description;&#13;
    mutable rate_limit_active: boolean = chain_context.args.rate_limit_active;&#13;
    mutable rate_limit_max_points: integer = chain_context.args.rate_limit_max_points;&#13;
    mutable rate_limit_recovery_time: integer = chain_context.args.rate_limit_recovery_time;&#13;
    mutable rate_limit_points_at_account_creation: integer = chain_context.args.rate_limit_points_at_account_creation;&#13;
}&#13;
&#13;
&#13;
//operation update_blockchain(name, website: text, description: text) {&#13;
//    blockchain.name = name;&#13;
//    blockchain.website = website;&#13;
//    blockchain.description = description;&#13;
//}&#13;
&#13;
query get_blockchain_info() {&#13;
    return (&#13;
        name = my_blockchain_info.name,&#13;
        website = my_blockchain_info.website,&#13;
        description = my_blockchain_info.description,&#13;
        rate_limit_active = my_blockchain_info.rate_limit_active,&#13;
        rate_limit_max_points = my_blockchain_info.rate_limit_max_points,&#13;
        rate_limit_recovery_time = my_blockchain_info.rate_limit_recovery_time,&#13;
        rate_limit_points_at_account_creation = chain_context.args.rate_limit_points_at_account_creation&#13;
    );&#13;
}&#13;
&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/core/transfer.rell">
                                <string>import acc: ^.account;&#13;
&#13;
struct xfer_input {&#13;
   account_id: byte_array;&#13;
   asset_id: byte_array;&#13;
   auth_descriptor_id: byte_array;&#13;
   amount: integer;&#13;
   extra: map&lt;text, gtv&gt;;&#13;
}&#13;
&#13;
struct xfer_output {&#13;
   account_id: byte_array;&#13;
   asset_id: byte_array;&#13;
   amount: integer;&#13;
   extra: map&lt;text, gtv&gt;;&#13;
}&#13;
&#13;
function deduct_balance (acc.account, asset, d_amount: integer) {&#13;
    val b = balance @ { account, asset };&#13;
    require( b.amount &gt;= d_amount, "Balance is too low");&#13;
    update b (amount -= d_amount);&#13;
}&#13;
&#13;
function consume_input (i: xfer_input, idx: integer, assets: map&lt;asset, integer&gt;): payment_history_entry {&#13;
      val asset = asset @ { .id == i.asset_id };&#13;
      val account = acc.auth_and_log(i.account_id, i.auth_descriptor_id, ["T"]);&#13;
      require( i.amount &gt; 0, "Amount should be non 0 positive." );&#13;
&#13;
      deduct_balance(account, asset, i.amount);&#13;
      assets[asset] = i.amount + if (asset in assets) assets[asset] else 0;&#13;
      return create payment_history_entry (&#13;
        account,&#13;
        asset,&#13;
        .delta = i.amount,&#13;
        .op_index = 500, //op_context ???&#13;
        .is_input = true,&#13;
        .entry_index = idx&#13;
      );&#13;
}&#13;
&#13;
function process_transfer_output (o: xfer_output, idx: integer, available_assets: map&lt;asset, integer&gt;): payment_history_entry {&#13;
      if (o.extra.contains("reg_auth_desc")) {&#13;
          val auth_desc = acc.auth_descriptor.from_gtv(o.extra["reg_auth_desc"]);&#13;
          require(o.account_id&#13;
           == acc.create_account_with_auth(auth_desc));&#13;
      }&#13;
&#13;
      val target_account = acc.account @ { .id == o.account_id };&#13;
      val asset = asset @ { .id == o.asset_id };&#13;
      require(o.amount &gt; 0, "You cannot tx output negative numbers");&#13;
      require( available_assets[asset] &gt;= o.amount );&#13;
      available_assets[asset] -= o.amount;&#13;
      require(available_assets[asset] &gt;= 0);&#13;
      val balance = ensure_balance(target_account, asset);&#13;
      balance.amount += o.amount;&#13;
&#13;
      return create payment_history_entry (&#13;
        .account = target_account,&#13;
        asset,&#13;
        .delta = o.amount,&#13;
&#13;
        .op_index = 500, // something from op_context,&#13;
        .is_input = false,&#13;
        .entry_index = idx&#13;
      );&#13;
}&#13;
&#13;
function _transfer (inputs: list&lt;xfer_input&gt;, outputs: list&lt;xfer_output&gt;) {&#13;
   val sum_inputs = map&lt;asset, integer&gt;();&#13;
   var idx = 0;&#13;
   for (i in inputs) {&#13;
      consume_input(i, idx, sum_inputs);&#13;
      idx += 1;&#13;
   }&#13;
&#13;
   idx = 0;&#13;
   for (o in outputs) {&#13;
      process_transfer_output(o, idx, sum_inputs);&#13;
      idx += 1;&#13;
   }&#13;
}&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/crosschain/blockchain.rell">
                                <string>import ft3: ^.core;&#13;
import acc: ^.account;&#13;
&#13;
&#13;
entity asset_origin {&#13;
    key ft3.asset;&#13;
    origin_chain_rid: byte_array;&#13;
}&#13;
&#13;
entity linked_chain {&#13;
    key chain_rid: byte_array;&#13;
}&#13;
&#13;
function blockchain_account_id (blockchain_rid: byte_array): byte_array {&#13;
   return ("B", blockchain_rid).hash();&#13;
}&#13;
&#13;
function ensure_blockchain_account (blockchain_rid: byte_array): acc.account {&#13;
   val blockchain_account_id = blockchain_account_id(blockchain_rid);&#13;
   val acc = acc.account @? { .id == blockchain_account_id };&#13;
   return if (acc??)  acc&#13;
   else create acc.account (id = blockchain_account_id);&#13;
}&#13;
&#13;
function get_blockchain_account (blockchain_rid: byte_array): acc.account {&#13;
   return acc.account @ { .id == blockchain_account_id(blockchain_rid) };&#13;
}&#13;
&#13;
&#13;
query get_linked_chains() {&#13;
    return linked_chain @* {} ( .chain_rid );&#13;
}&#13;
&#13;
query is_linked_with_chain(chain_rid: byte_array) {&#13;
    return linked_chain @? { chain_rid } != null;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/crosschain/module.rell">
                                <string>@mount('ft3.xc')&#13;
module;&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/crosschain/structures.rell">
                                <string>struct operation_rec {&#13;
   name;&#13;
   args: list&lt;gtv&gt;;&#13;
}&#13;
&#13;
struct transaction_body_rec {&#13;
    blockchain_rid: byte_array;&#13;
    operations: list&lt;operation_rec&gt;;&#13;
    signers: list&lt;gtv&gt;;&#13;
}&#13;
&#13;
struct transaction_rec {&#13;
   body: transaction_body_rec;&#13;
   signatures: list&lt;gtv&gt;;&#13;
}&#13;
&#13;
struct transaction_proof {&#13;
     tx: virtual&lt;transaction_rec&gt;;&#13;
     // block_header: byte_array;&#13;
     // merkle_path: virtual&lt;list&lt;byte_array&gt;&gt;;&#13;
     // tx_index: integer;&#13;
     block_rid: byte_array;&#13;
     block_signers: list&lt;byte_array&gt;;&#13;
     signatures: list&lt;byte_array&gt;;     &#13;
}&#13;
&#13;
function verify_transaction_proof( p: transaction_proof ) {&#13;
   // TODO&#13;
}</string>
                            </entry>
                            <entry key="rell_modules/ft3/crosschain/transfer.rell">
                                <string>import ft3: ^.core;&#13;
&#13;
struct xc_target {&#13;
    account_id: byte_array;&#13;
    extra: map&lt;text, gtv&gt;;&#13;
}&#13;
&#13;
function add_to_blockchain_balance (blockchain_rid: byte_array, ft3.asset, amount: integer) {&#13;
    require( chain_context.blockchain_rid != blockchain_rid ); // cannot add to own account&#13;
&#13;
    val origin_chain_rid = asset_origin @? { asset } .origin_chain_rid;&#13;
&#13;
    if (exists(origin_chain_rid) and (blockchain_rid == origin_chain_rid)) {&#13;
       // do nothing. in future we might track origin&#13;
    } else {&#13;
         val bc_acc = ensure_blockchain_account(blockchain_rid);&#13;
         ft3.ensure_balance(bc_acc, asset).amount += amount;&#13;
    }&#13;
}&#13;
&#13;
&#13;
struct init_xfer_args {&#13;
          source: ft3.xfer_input;&#13;
          target: xc_target;&#13;
          hops: list&lt;byte_array&gt;;&#13;
}&#13;
&#13;
entity applied_transfers { key tx_rid: byte_array; }&#13;
&#13;
&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/operations/dev_op_account.rell">
                                <string>@mount('ft3')&#13;
module;&#13;
&#13;
import dev_op: ^^.core.dev_op;&#13;
import acc: ^^.account; &#13;
&#13;
&#13;
operation dev_register_account (acc.auth_descriptor) {&#13;
    dev_op.require_dev();&#13;
    acc.create_account_with_auth( auth_descriptor );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/operations/dev_op_asset.rell">
                                <string>@mount('ft3')&#13;
module;&#13;
&#13;
import dev_op: ^^.core.dev_op;&#13;
import ft3: ^^.core;&#13;
&#13;
import xft3: ^^.crosschain; &#13;
&#13;
operation dev_register_asset (name, issuing_chain_rid: byte_array) {&#13;
    dev_op.require_dev();&#13;
    ft3.register_asset(name, issuing_chain_rid);&#13;
}&#13;
&#13;
operation dev_register_xc_asset (name, issuing_chain_rid: byte_array, origin_chain_rid: byte_array) {&#13;
    dev_op.require_dev();   &#13;
    val asset = ft3.register_asset(name, issuing_chain_rid);&#13;
    create xft3.asset_origin (asset, origin_chain_rid);&#13;
}&#13;
</string>
                            </entry>
                            <entry key="rell_modules/ft3/operations/dev_op_balance.rell">
                                <string>@mount('ft3')&#13;
module;&#13;
&#13;
import dev_op: ^^.core.dev_op;&#13;
import ft3: ^^.core;&#13;
import acc: ^^.account;&#13;
&#13;
&#13;
operation dev_give_balance (asset_id: byte_array, account_id: byte_array, amount: integer) {&#13;
    dev_op.require_dev();&#13;
    require(amount &gt;= 0);&#13;
    ft3.ensure_balance( acc.account @ { account_id }, ft3.asset @ { .id == asset_id } ).amount += amount;&#13;
}</string>
                            </entry>
                        </dict>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="signers">
        <array>
            <bytea>0350FE40766BC0CE8D08B3F5B810E49A8352FDD458606BD5FAFE5ACDCDC8FF3F57</bytea>
        </array>
    </entry>
</dict>
